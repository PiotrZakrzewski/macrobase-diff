# Generated from mbdiff/diff_grammar/SqlBase.g4 by ANTLR 4.9
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u00e4")
        buf.write("\u03d0\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\3\2\3\2\3\2\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\4\3\4\3\4\3\4\7\4q\n\4\f\4\16\4t\13\4\3\4\3\4")
        buf.write("\5\4x\n\4\5\4z\n\4\3\5\3\5\3\6\3\6\3\7\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\3\7\5\7\u0088\n\7\3\b\3\b\5\b\u008c\n\b\3\b\3")
        buf.write("\b\3\b\7\b\u0091\n\b\f\b\16\b\u0094\13\b\3\b\3\b\3\b\3")
        buf.write("\b\7\b\u009a\n\b\f\b\16\b\u009d\13\b\5\b\u009f\n\b\3\b")
        buf.write("\3\b\5\b\u00a3\n\b\3\b\3\b\3\b\3\b\3\b\7\b\u00aa\n\b\f")
        buf.write("\b\16\b\u00ad\13\b\5\b\u00af\n\b\3\b\3\b\5\b\u00b3\n\b")
        buf.write("\3\b\5\b\u00b6\n\b\3\b\3\b\5\b\u00ba\n\b\3\b\3\b\3\b\7")
        buf.write("\b\u00bf\n\b\f\b\16\b\u00c2\13\b\3\b\5\b\u00c5\n\b\3\b")
        buf.write("\3\b\3\b\3\b\7\b\u00cb\n\b\f\b\16\b\u00ce\13\b\5\b\u00d0")
        buf.write("\n\b\3\b\3\b\5\b\u00d4\n\b\3\b\3\b\3\b\3\b\3\b\7\b\u00db")
        buf.write("\n\b\f\b\16\b\u00de\13\b\5\b\u00e0\n\b\3\b\3\b\5\b\u00e4")
        buf.write("\n\b\5\b\u00e6\n\b\3\t\3\t\5\t\u00ea\n\t\3\t\3\t\3\t\7")
        buf.write("\t\u00ef\n\t\f\t\16\t\u00f2\13\t\3\t\3\t\3\t\3\t\5\t\u00f8")
        buf.write("\n\t\3\t\3\t\3\t\5\t\u00fd\n\t\3\t\3\t\3\t\5\t\u0102\n")
        buf.write("\t\3\t\3\t\5\t\u0106\n\t\3\t\5\t\u0109\n\t\3\t\5\t\u010c")
        buf.write("\n\t\3\t\5\t\u010f\n\t\5\t\u0111\n\t\5\t\u0113\n\t\3\t")
        buf.write("\3\t\3\t\5\t\u0118\n\t\3\t\3\t\3\t\5\t\u011d\n\t\3\t\3")
        buf.write("\t\5\t\u0121\n\t\3\t\3\t\3\t\3\t\3\t\7\t\u0128\n\t\f\t")
        buf.write("\16\t\u012b\13\t\5\t\u012d\n\t\3\t\3\t\5\t\u0131\n\t\3")
        buf.write("\t\5\t\u0134\n\t\3\t\3\t\5\t\u0138\n\t\3\t\3\t\3\t\7\t")
        buf.write("\u013d\n\t\f\t\16\t\u0140\13\t\3\t\5\t\u0143\n\t\3\t\3")
        buf.write("\t\3\t\3\t\5\t\u0149\n\t\3\t\3\t\3\t\5\t\u014e\n\t\3\t")
        buf.write("\3\t\3\t\5\t\u0153\n\t\3\t\3\t\5\t\u0157\n\t\3\t\5\t\u015a")
        buf.write("\n\t\3\t\5\t\u015d\n\t\3\t\5\t\u0160\n\t\5\t\u0162\n\t")
        buf.write("\5\t\u0164\n\t\3\t\3\t\3\t\5\t\u0169\n\t\3\t\3\t\3\t\5")
        buf.write("\t\u016e\n\t\3\t\3\t\5\t\u0172\n\t\3\t\3\t\3\t\3\t\3\t")
        buf.write("\7\t\u0179\n\t\f\t\16\t\u017c\13\t\5\t\u017e\n\t\3\t\3")
        buf.write("\t\5\t\u0182\n\t\3\t\3\t\5\t\u0186\n\t\3\t\3\t\3\t\7\t")
        buf.write("\u018b\n\t\f\t\16\t\u018e\13\t\3\t\3\t\3\t\3\t\3\t\3\t")
        buf.write("\3\t\3\t\5\t\u0198\n\t\3\t\3\t\5\t\u019c\n\t\3\t\5\t\u019f")
        buf.write("\n\t\3\t\5\t\u01a2\n\t\3\t\5\t\u01a5\n\t\5\t\u01a7\n\t")
        buf.write("\5\t\u01a9\n\t\3\t\3\t\3\t\5\t\u01ae\n\t\3\t\3\t\3\t\5")
        buf.write("\t\u01b3\n\t\3\t\3\t\5\t\u01b7\n\t\3\t\3\t\3\t\3\t\3\t")
        buf.write("\7\t\u01be\n\t\f\t\16\t\u01c1\13\t\5\t\u01c3\n\t\3\t\3")
        buf.write("\t\5\t\u01c7\n\t\3\t\5\t\u01ca\n\t\3\t\3\t\5\t\u01ce\n")
        buf.write("\t\3\t\3\t\3\t\7\t\u01d3\n\t\f\t\16\t\u01d6\13\t\3\t\5")
        buf.write("\t\u01d9\n\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\5\t\u01e3")
        buf.write("\n\t\3\t\3\t\5\t\u01e7\n\t\3\t\5\t\u01ea\n\t\3\t\5\t\u01ed")
        buf.write("\n\t\3\t\5\t\u01f0\n\t\5\t\u01f2\n\t\5\t\u01f4\n\t\3\t")
        buf.write("\3\t\3\t\5\t\u01f9\n\t\3\t\3\t\3\t\5\t\u01fe\n\t\3\t\3")
        buf.write("\t\5\t\u0202\n\t\3\t\3\t\3\t\3\t\3\t\7\t\u0209\n\t\f\t")
        buf.write("\16\t\u020c\13\t\5\t\u020e\n\t\3\t\3\t\5\t\u0212\n\t\5")
        buf.write("\t\u0214\n\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\5")
        buf.write("\n\u0220\n\n\3\13\3\13\3\13\3\13\5\13\u0226\n\13\3\f\3")
        buf.write("\f\5\f\u022a\n\f\3\f\3\f\5\f\u022e\n\f\3\r\3\r\3\r\3\r")
        buf.write("\3\16\3\16\3\16\3\17\3\17\3\17\3\17\3\17\3\20\3\20\3\20")
        buf.write("\3\20\3\20\3\21\3\21\3\22\3\22\3\23\3\23\5\23\u0247\n")
        buf.write("\23\3\23\5\23\u024a\n\23\3\23\3\23\3\23\3\23\3\23\5\23")
        buf.write("\u0251\n\23\3\24\3\24\3\24\3\24\3\24\5\24\u0258\n\24\3")
        buf.write("\24\3\24\5\24\u025c\n\24\3\25\3\25\3\25\3\25\3\26\3\26")
        buf.write("\3\26\3\26\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27")
        buf.write("\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27\5\27\u0277\n")
        buf.write("\27\7\27\u0279\n\27\f\27\16\27\u027c\13\27\3\30\5\30\u027f")
        buf.write("\n\30\3\30\3\30\5\30\u0283\n\30\3\30\3\30\5\30\u0287\n")
        buf.write("\30\3\30\3\30\5\30\u028b\n\30\5\30\u028d\n\30\3\31\3\31")
        buf.write("\3\31\3\31\3\31\3\31\3\31\7\31\u0296\n\31\f\31\16\31\u0299")
        buf.write("\13\31\3\31\3\31\5\31\u029d\n\31\3\32\3\32\5\32\u02a1")
        buf.write("\n\32\3\32\3\32\3\32\3\32\3\32\5\32\u02a8\n\32\5\32\u02aa")
        buf.write("\n\32\3\33\3\33\3\33\7\33\u02af\n\33\f\33\16\33\u02b2")
        buf.write("\13\33\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\5")
        buf.write("\34\u02bd\n\34\3\35\3\35\3\36\3\36\3\36\3\36\5\36\u02c5")
        buf.write("\n\36\3\36\3\36\3\36\3\36\3\36\3\36\7\36\u02cd\n\36\f")
        buf.write("\36\16\36\u02d0\13\36\3\37\3\37\5\37\u02d4\n\37\3 \3 ")
        buf.write("\3 \3 \3 \3 \3 \3 \3 \3 \5 \u02e0\n \3 \3 \3 \3 \3 \3")
        buf.write(" \5 \u02e8\n \3 \3 \3 \3 \3 \7 \u02ef\n \f \16 \u02f2")
        buf.write("\13 \3 \3 \3 \5 \u02f7\n \3 \3 \3 \3 \3 \3 \5 \u02ff\n")
        buf.write(" \3 \3 \3 \3 \5 \u0305\n \3 \3 \5 \u0309\n \3 \3 \3 \5")
        buf.write(" \u030e\n \3 \3 \3 \5 \u0313\n \3!\3!\3!\3!\5!\u0319\n")
        buf.write("!\3!\3!\3!\3!\3!\3!\3!\3!\3!\7!\u0324\n!\f!\16!\u0327")
        buf.write("\13!\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3")
        buf.write("\"\3\"\3\"\3\"\5\"\u0339\n\"\3\"\3\"\3\"\5\"\u033e\n\"")
        buf.write("\3\"\3\"\3\"\7\"\u0343\n\"\f\"\16\"\u0346\13\"\5\"\u0348")
        buf.write("\n\"\3\"\3\"\5\"\u034c\n\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"")
        buf.write("\3\"\3\"\3\"\3\"\3\"\3\"\3\"\5\"\u035c\n\"\3\"\3\"\3\"")
        buf.write("\7\"\u0361\n\"\f\"\16\"\u0364\13\"\3#\3#\3#\3#\5#\u036a")
        buf.write("\n#\5#\u036c\n#\3$\3$\3%\3%\3&\3&\3\'\3\'\3\'\3\'\3\'")
        buf.write("\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3")
        buf.write("\'\3\'\3\'\7\'\u0389\n\'\f\'\16\'\u038c\13\'\3\'\3\'\3")
        buf.write("\'\3\'\3\'\3\'\3\'\7\'\u0395\n\'\f\'\16\'\u0398\13\'\3")
        buf.write("\'\3\'\5\'\u039c\n\'\5\'\u039e\n\'\3\'\3\'\7\'\u03a2\n")
        buf.write("\'\f\'\16\'\u03a5\13\'\3(\3(\5(\u03a9\n(\3)\3)\3)\3)\5")
        buf.write(")\u03af\n)\3*\3*\3*\3*\3*\3+\3+\3+\3+\3+\3+\3,\3,\3,\7")
        buf.write(",\u03bf\n,\f,\16,\u03c2\13,\3-\3-\3-\3-\5-\u03c8\n-\3")
        buf.write(".\3.\5.\u03cc\n.\3/\3/\3/\2\7,:@BL\60\2\4\6\b\n\f\16\20")
        buf.write("\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJL")
        buf.write("NPRTVXZ\\\2\16\4\2\b\b\u00d7\u00d7\4\2\17\17--\4\2BB^")
        buf.write("^\5\2\"\"gh\u00a7\u00a7\4\2\b\b\60\60\4\2\33\33??\3\2")
        buf.write("\u00ce\u00cf\3\2\u00d0\u00d2\3\2\u00c8\u00cd\5\2\b\b\f")
        buf.write("\f\u00a1\u00a1\4\2>>\u00b3\u00b3\63\2\7\b\n\n\f\r\17\21")
        buf.write("\24\25\30\33\35\37\'*--\61\6199<<ACEEHKOPSSUUWWYY\\\\")
        buf.write("^_aaccefjkmqtuwx||\177\u0084\u0086\u0089\u008b\u008b\u008d")
        buf.write("\u0092\u0094\u0094\u0096\u009a\u009c\u00a1\u00a3\u00a3")
        buf.write("\u00a5\u00a6\u00a8\u00a8\u00aa\u00ab\u00ad\u00ad\u00af")
        buf.write("\u00b2\u00b4\u00b5\u00b7\u00b8\u00bb\u00bb\u00bd\u00bd")
        buf.write("\u00bf\u00c0\u00c4\u00c7\2\u0458\2^\3\2\2\2\4a\3\2\2\2")
        buf.write("\6y\3\2\2\2\b{\3\2\2\2\n}\3\2\2\2\f\u0087\3\2\2\2\16\u00e5")
        buf.write("\3\2\2\2\20\u0213\3\2\2\2\22\u021f\3\2\2\2\24\u0221\3")
        buf.write("\2\2\2\26\u0227\3\2\2\2\30\u022f\3\2\2\2\32\u0233\3\2")
        buf.write("\2\2\34\u0236\3\2\2\2\36\u023b\3\2\2\2 \u0240\3\2\2\2")
        buf.write("\"\u0242\3\2\2\2$\u0250\3\2\2\2&\u0252\3\2\2\2(\u025d")
        buf.write("\3\2\2\2*\u0261\3\2\2\2,\u0265\3\2\2\2.\u028c\3\2\2\2")
        buf.write("\60\u029c\3\2\2\2\62\u029e\3\2\2\2\64\u02ab\3\2\2\2\66")
        buf.write("\u02bc\3\2\2\28\u02be\3\2\2\2:\u02c4\3\2\2\2<\u02d1\3")
        buf.write("\2\2\2>\u0312\3\2\2\2@\u0318\3\2\2\2B\u035b\3\2\2\2D\u036b")
        buf.write("\3\2\2\2F\u036d\3\2\2\2H\u036f\3\2\2\2J\u0371\3\2\2\2")
        buf.write("L\u039d\3\2\2\2N\u03a8\3\2\2\2P\u03ae\3\2\2\2R\u03b0\3")
        buf.write("\2\2\2T\u03b5\3\2\2\2V\u03bb\3\2\2\2X\u03c7\3\2\2\2Z\u03cb")
        buf.write("\3\2\2\2\\\u03cd\3\2\2\2^_\5\6\4\2_`\7\2\2\3`\3\3\2\2")
        buf.write("\2ab\58\35\2bc\7\2\2\3c\5\3\2\2\2dz\5\b\5\2ef\7Q\2\2f")
        buf.write("g\7F\2\2gh\7$\2\2hi\7@\2\2ij\7\u00d4\2\2jk\7Z\2\2kw\5")
        buf.write("V,\2lm\7\3\2\2mr\5\24\13\2no\7\4\2\2oq\5\24\13\2pn\3\2")
        buf.write("\2\2qt\3\2\2\2rp\3\2\2\2rs\3\2\2\2su\3\2\2\2tr\3\2\2\2")
        buf.write("uv\7\5\2\2vx\3\2\2\2wl\3\2\2\2wx\3\2\2\2xz\3\2\2\2yd\3")
        buf.write("\2\2\2ye\3\2\2\2z\7\3\2\2\2{|\5\n\6\2|\t\3\2\2\2}~\5\f")
        buf.write("\7\2~\13\3\2\2\2\177\u0088\5\16\b\2\u0080\u0088\5\20\t")
        buf.write("\2\u0081\u0082\7\u00a9\2\2\u0082\u0088\5V,\2\u0083\u0084")
        buf.write("\7\3\2\2\u0084\u0085\5\b\5\2\u0085\u0086\7\5\2\2\u0086")
        buf.write("\u0088\3\2\2\2\u0087\177\3\2\2\2\u0087\u0080\3\2\2\2\u0087")
        buf.write("\u0081\3\2\2\2\u0087\u0083\3\2\2\2\u0088\r\3\2\2\2\u0089")
        buf.write("\u008b\7\u009b\2\2\u008a\u008c\5\"\22\2\u008b\u008a\3")
        buf.write("\2\2\2\u008b\u008c\3\2\2\2\u008c\u008d\3\2\2\2\u008d\u0092")
        buf.write("\5$\23\2\u008e\u008f\7\4\2\2\u008f\u0091\5$\23\2\u0090")
        buf.write("\u008e\3\2\2\2\u0091\u0094\3\2\2\2\u0092\u0090\3\2\2\2")
        buf.write("\u0092\u0093\3\2\2\2\u0093\u009e\3\2\2\2\u0094\u0092\3")
        buf.write("\2\2\2\u0095\u0096\7F\2\2\u0096\u009b\5,\27\2\u0097\u0098")
        buf.write("\7\4\2\2\u0098\u009a\5,\27\2\u0099\u0097\3\2\2\2\u009a")
        buf.write("\u009d\3\2\2\2\u009b\u0099\3\2\2\2\u009b\u009c\3\2\2\2")
        buf.write("\u009c\u009f\3\2\2\2\u009d\u009b\3\2\2\2\u009e\u0095\3")
        buf.write("\2\2\2\u009e\u009f\3\2\2\2\u009f\u00a2\3\2\2\2\u00a0\u00a1")
        buf.write("\7\u00c2\2\2\u00a1\u00a3\5:\36\2\u00a2\u00a0\3\2\2\2\u00a2")
        buf.write("\u00a3\3\2\2\2\u00a3\u00ae\3\2\2\2\u00a4\u00a5\7{\2\2")
        buf.write("\u00a5\u00a6\7\23\2\2\u00a6\u00ab\5\26\f\2\u00a7\u00a8")
        buf.write("\7\4\2\2\u00a8\u00aa\5\26\f\2\u00a9\u00a7\3\2\2\2\u00aa")
        buf.write("\u00ad\3\2\2\2\u00ab\u00a9\3\2\2\2\u00ab\u00ac\3\2\2\2")
        buf.write("\u00ac\u00af\3\2\2\2\u00ad\u00ab\3\2\2\2\u00ae\u00a4\3")
        buf.write("\2\2\2\u00ae\u00af\3\2\2\2\u00af\u00b2\3\2\2\2\u00b0\u00b1")
        buf.write("\7c\2\2\u00b1\u00b3\t\2\2\2\u00b2\u00b0\3\2\2\2\u00b2")
        buf.write("\u00b3\3\2\2\2\u00b3\u00b5\3\2\2\2\u00b4\u00b6\5&\24\2")
        buf.write("\u00b5\u00b4\3\2\2\2\u00b5\u00b6\3\2\2\2\u00b6\u00e6\3")
        buf.write("\2\2\2\u00b7\u00b9\7\u009b\2\2\u00b8\u00ba\5\"\22\2\u00b9")
        buf.write("\u00b8\3\2\2\2\u00b9\u00ba\3\2\2\2\u00ba\u00bb\3\2\2\2")
        buf.write("\u00bb\u00c0\5$\23\2\u00bc\u00bd\7\4\2\2\u00bd\u00bf\5")
        buf.write("$\23\2\u00be\u00bc\3\2\2\2\u00bf\u00c2\3\2\2\2\u00c0\u00be")
        buf.write("\3\2\2\2\u00c0\u00c1\3\2\2\2\u00c1\u00c4\3\2\2\2\u00c2")
        buf.write("\u00c0\3\2\2\2\u00c3\u00c5\5&\24\2\u00c4\u00c3\3\2\2\2")
        buf.write("\u00c4\u00c5\3\2\2\2\u00c5\u00cf\3\2\2\2\u00c6\u00c7\7")
        buf.write("F\2\2\u00c7\u00cc\5,\27\2\u00c8\u00c9\7\4\2\2\u00c9\u00cb")
        buf.write("\5,\27\2\u00ca\u00c8\3\2\2\2\u00cb\u00ce\3\2\2\2\u00cc")
        buf.write("\u00ca\3\2\2\2\u00cc\u00cd\3\2\2\2\u00cd\u00d0\3\2\2\2")
        buf.write("\u00ce\u00cc\3\2\2\2\u00cf\u00c6\3\2\2\2\u00cf\u00d0\3")
        buf.write("\2\2\2\u00d0\u00d3\3\2\2\2\u00d1\u00d2\7\u00c2\2\2\u00d2")
        buf.write("\u00d4\5:\36\2\u00d3\u00d1\3\2\2\2\u00d3\u00d4\3\2\2\2")
        buf.write("\u00d4\u00df\3\2\2\2\u00d5\u00d6\7{\2\2\u00d6\u00d7\7")
        buf.write("\23\2\2\u00d7\u00dc\5\26\f\2\u00d8\u00d9\7\4\2\2\u00d9")
        buf.write("\u00db\5\26\f\2\u00da\u00d8\3\2\2\2\u00db\u00de\3\2\2")
        buf.write("\2\u00dc\u00da\3\2\2\2\u00dc\u00dd\3\2\2\2\u00dd\u00e0")
        buf.write("\3\2\2\2\u00de\u00dc\3\2\2\2\u00df\u00d5\3\2\2\2\u00df")
        buf.write("\u00e0\3\2\2\2\u00e0\u00e3\3\2\2\2\u00e1\u00e2\7c\2\2")
        buf.write("\u00e2\u00e4\t\2\2\2\u00e3\u00e1\3\2\2\2\u00e3\u00e4\3")
        buf.write("\2\2\2\u00e4\u00e6\3\2\2\2\u00e5\u0089\3\2\2\2\u00e5\u00b7")
        buf.write("\3\2\2\2\u00e6\17\3\2\2\2\u00e7\u00e9\7\u009b\2\2\u00e8")
        buf.write("\u00ea\5\"\22\2\u00e9\u00e8\3\2\2\2\u00e9\u00ea\3\2\2")
        buf.write("\2\u00ea\u00eb\3\2\2\2\u00eb\u00f0\5$\23\2\u00ec\u00ed")
        buf.write("\7\4\2\2\u00ed\u00ef\5$\23\2\u00ee\u00ec\3\2\2\2\u00ef")
        buf.write("\u00f2\3\2\2\2\u00f0\u00ee\3\2\2\2\u00f0\u00f1\3\2\2\2")
        buf.write("\u00f1\u00f3\3\2\2\2\u00f2\u00f0\3\2\2\2\u00f3\u00f4\7")
        buf.write("F\2\2\u00f4\u00f5\7/\2\2\u00f5\u00f7\5\n\6\2\u00f6\u00f8")
        buf.write("\5V,\2\u00f7\u00f6\3\2\2\2\u00f7\u00f8\3\2\2\2\u00f8\u00f9")
        buf.write("\3\2\2\2\u00f9\u00fa\7\4\2\2\u00fa\u00fc\5\n\6\2\u00fb")
        buf.write("\u00fd\5V,\2\u00fc\u00fb\3\2\2\2\u00fc\u00fd\3\2\2\2\u00fd")
        buf.write("\u00fe\3\2\2\2\u00fe\u0101\7v\2\2\u00ff\u0102\5\64\33")
        buf.write("\2\u0100\u0102\7\u00d0\2\2\u0101\u00ff\3\2\2\2\u0101\u0100")
        buf.write("\3\2\2\2\u0102\u0112\3\2\2\2\u0103\u0110\7\u00c3\2\2\u0104")
        buf.write("\u0106\5\30\r\2\u0105\u0104\3\2\2\2\u0105\u0106\3\2\2")
        buf.write("\2\u0106\u0108\3\2\2\2\u0107\u0109\5\32\16\2\u0108\u0107")
        buf.write("\3\2\2\2\u0108\u0109\3\2\2\2\u0109\u0111\3\2\2\2\u010a")
        buf.write("\u010c\5\32\16\2\u010b\u010a\3\2\2\2\u010b\u010c\3\2\2")
        buf.write("\2\u010c\u010e\3\2\2\2\u010d\u010f\5\30\r\2\u010e\u010d")
        buf.write("\3\2\2\2\u010e\u010f\3\2\2\2\u010f\u0111\3\2\2\2\u0110")
        buf.write("\u0105\3\2\2\2\u0110\u010b\3\2\2\2\u0111\u0113\3\2\2\2")
        buf.write("\u0112\u0103\3\2\2\2\u0112\u0113\3\2\2\2\u0113\u0117\3")
        buf.write("\2\2\2\u0114\u0115\7 \2\2\u0115\u0116\7\23\2\2\u0116\u0118")
        buf.write("\5\34\17\2\u0117\u0114\3\2\2\2\u0117\u0118\3\2\2\2\u0118")
        buf.write("\u011c\3\2\2\2\u0119\u011a\7g\2\2\u011a\u011b\7\34\2\2")
        buf.write("\u011b\u011d\7\u00d7\2\2\u011c\u0119\3\2\2\2\u011c\u011d")
        buf.write("\3\2\2\2\u011d\u0120\3\2\2\2\u011e\u011f\7\u00c2\2\2\u011f")
        buf.write("\u0121\5:\36\2\u0120\u011e\3\2\2\2\u0120\u0121\3\2\2\2")
        buf.write("\u0121\u012c\3\2\2\2\u0122\u0123\7{\2\2\u0123\u0124\7")
        buf.write("\23\2\2\u0124\u0129\5\26\f\2\u0125\u0126\7\4\2\2\u0126")
        buf.write("\u0128\5\26\f\2\u0127\u0125\3\2\2\2\u0128\u012b\3\2\2")
        buf.write("\2\u0129\u0127\3\2\2\2\u0129\u012a\3\2\2\2\u012a\u012d")
        buf.write("\3\2\2\2\u012b\u0129\3\2\2\2\u012c\u0122\3\2\2\2\u012c")
        buf.write("\u012d\3\2\2\2\u012d\u0130\3\2\2\2\u012e\u012f\7c\2\2")
        buf.write("\u012f\u0131\t\2\2\2\u0130\u012e\3\2\2\2\u0130\u0131\3")
        buf.write("\2\2\2\u0131\u0133\3\2\2\2\u0132\u0134\5&\24\2\u0133\u0132")
        buf.write("\3\2\2\2\u0133\u0134\3\2\2\2\u0134\u0214\3\2\2\2\u0135")
        buf.write("\u0137\7\u009b\2\2\u0136\u0138\5\"\22\2\u0137\u0136\3")
        buf.write("\2\2\2\u0137\u0138\3\2\2\2\u0138\u0139\3\2\2\2\u0139\u013e")
        buf.write("\5$\23\2\u013a\u013b\7\4\2\2\u013b\u013d\5$\23\2\u013c")
        buf.write("\u013a\3\2\2\2\u013d\u0140\3\2\2\2\u013e\u013c\3\2\2\2")
        buf.write("\u013e\u013f\3\2\2\2\u013f\u0142\3\2\2\2\u0140\u013e\3")
        buf.write("\2\2\2\u0141\u0143\5&\24\2\u0142\u0141\3\2\2\2\u0142\u0143")
        buf.write("\3\2\2\2\u0143\u0144\3\2\2\2\u0144\u0145\7F\2\2\u0145")
        buf.write("\u0146\7/\2\2\u0146\u0148\5\n\6\2\u0147\u0149\5V,\2\u0148")
        buf.write("\u0147\3\2\2\2\u0148\u0149\3\2\2\2\u0149\u014a\3\2\2\2")
        buf.write("\u014a\u014b\7\4\2\2\u014b\u014d\5\n\6\2\u014c\u014e\5")
        buf.write("V,\2\u014d\u014c\3\2\2\2\u014d\u014e\3\2\2\2\u014e\u014f")
        buf.write("\3\2\2\2\u014f\u0152\7v\2\2\u0150\u0153\5\64\33\2\u0151")
        buf.write("\u0153\7\u00d0\2\2\u0152\u0150\3\2\2\2\u0152\u0151\3\2")
        buf.write("\2\2\u0153\u0163\3\2\2\2\u0154\u0161\7\u00c3\2\2\u0155")
        buf.write("\u0157\5\30\r\2\u0156\u0155\3\2\2\2\u0156\u0157\3\2\2")
        buf.write("\2\u0157\u0159\3\2\2\2\u0158\u015a\5\32\16\2\u0159\u0158")
        buf.write("\3\2\2\2\u0159\u015a\3\2\2\2\u015a\u0162\3\2\2\2\u015b")
        buf.write("\u015d\5\32\16\2\u015c\u015b\3\2\2\2\u015c\u015d\3\2\2")
        buf.write("\2\u015d\u015f\3\2\2\2\u015e\u0160\5\30\r\2\u015f\u015e")
        buf.write("\3\2\2\2\u015f\u0160\3\2\2\2\u0160\u0162\3\2\2\2\u0161")
        buf.write("\u0156\3\2\2\2\u0161\u015c\3\2\2\2\u0162\u0164\3\2\2\2")
        buf.write("\u0163\u0154\3\2\2\2\u0163\u0164\3\2\2\2\u0164\u0168\3")
        buf.write("\2\2\2\u0165\u0166\7 \2\2\u0166\u0167\7\23\2\2\u0167\u0169")
        buf.write("\5\34\17\2\u0168\u0165\3\2\2\2\u0168\u0169\3\2\2\2\u0169")
        buf.write("\u016d\3\2\2\2\u016a\u016b\7g\2\2\u016b\u016c\7\34\2\2")
        buf.write("\u016c\u016e\7\u00d7\2\2\u016d\u016a\3\2\2\2\u016d\u016e")
        buf.write("\3\2\2\2\u016e\u0171\3\2\2\2\u016f\u0170\7\u00c2\2\2\u0170")
        buf.write("\u0172\5:\36\2\u0171\u016f\3\2\2\2\u0171\u0172\3\2\2\2")
        buf.write("\u0172\u017d\3\2\2\2\u0173\u0174\7{\2\2\u0174\u0175\7")
        buf.write("\23\2\2\u0175\u017a\5\26\f\2\u0176\u0177\7\4\2\2\u0177")
        buf.write("\u0179\5\26\f\2\u0178\u0176\3\2\2\2\u0179\u017c\3\2\2")
        buf.write("\2\u017a\u0178\3\2\2\2\u017a\u017b\3\2\2\2\u017b\u017e")
        buf.write("\3\2\2\2\u017c\u017a\3\2\2\2\u017d\u0173\3\2\2\2\u017d")
        buf.write("\u017e\3\2\2\2\u017e\u0181\3\2\2\2\u017f\u0180\7c\2\2")
        buf.write("\u0180\u0182\t\2\2\2\u0181\u017f\3\2\2\2\u0181\u0182\3")
        buf.write("\2\2\2\u0182\u0214\3\2\2\2\u0183\u0185\7\u009b\2\2\u0184")
        buf.write("\u0186\5\"\22\2\u0185\u0184\3\2\2\2\u0185\u0186\3\2\2")
        buf.write("\2\u0186\u0187\3\2\2\2\u0187\u018c\5$\23\2\u0188\u0189")
        buf.write("\7\4\2\2\u0189\u018b\5$\23\2\u018a\u0188\3\2\2\2\u018b")
        buf.write("\u018e\3\2\2\2\u018c\u018a\3\2\2\2\u018c\u018d\3\2\2\2")
        buf.write("\u018d\u018f\3\2\2\2\u018e\u018c\3\2\2\2\u018f\u0190\7")
        buf.write("F\2\2\u0190\u0191\7/\2\2\u0191\u0192\7\3\2\2\u0192\u0193")
        buf.write("\5\22\n\2\u0193\u0194\7\5\2\2\u0194\u0197\7v\2\2\u0195")
        buf.write("\u0198\5\64\33\2\u0196\u0198\7\u00d0\2\2\u0197\u0195\3")
        buf.write("\2\2\2\u0197\u0196\3\2\2\2\u0198\u01a8\3\2\2\2\u0199\u01a6")
        buf.write("\7\u00c3\2\2\u019a\u019c\5\30\r\2\u019b\u019a\3\2\2\2")
        buf.write("\u019b\u019c\3\2\2\2\u019c\u019e\3\2\2\2\u019d\u019f\5")
        buf.write("\32\16\2\u019e\u019d\3\2\2\2\u019e\u019f\3\2\2\2\u019f")
        buf.write("\u01a7\3\2\2\2\u01a0\u01a2\5\32\16\2\u01a1\u01a0\3\2\2")
        buf.write("\2\u01a1\u01a2\3\2\2\2\u01a2\u01a4\3\2\2\2\u01a3\u01a5")
        buf.write("\5\30\r\2\u01a4\u01a3\3\2\2\2\u01a4\u01a5\3\2\2\2\u01a5")
        buf.write("\u01a7\3\2\2\2\u01a6\u019b\3\2\2\2\u01a6\u01a1\3\2\2\2")
        buf.write("\u01a7\u01a9\3\2\2\2\u01a8\u0199\3\2\2\2\u01a8\u01a9\3")
        buf.write("\2\2\2\u01a9\u01ad\3\2\2\2\u01aa\u01ab\7 \2\2\u01ab\u01ac")
        buf.write("\7\23\2\2\u01ac\u01ae\5\34\17\2\u01ad\u01aa\3\2\2\2\u01ad")
        buf.write("\u01ae\3\2\2\2\u01ae\u01b2\3\2\2\2\u01af\u01b0\7g\2\2")
        buf.write("\u01b0\u01b1\7\34\2\2\u01b1\u01b3\7\u00d7\2\2\u01b2\u01af")
        buf.write("\3\2\2\2\u01b2\u01b3\3\2\2\2\u01b3\u01b6\3\2\2\2\u01b4")
        buf.write("\u01b5\7\u00c2\2\2\u01b5\u01b7\5:\36\2\u01b6\u01b4\3\2")
        buf.write("\2\2\u01b6\u01b7\3\2\2\2\u01b7\u01c2\3\2\2\2\u01b8\u01b9")
        buf.write("\7{\2\2\u01b9\u01ba\7\23\2\2\u01ba\u01bf\5\26\f\2\u01bb")
        buf.write("\u01bc\7\4\2\2\u01bc\u01be\5\26\f\2\u01bd\u01bb\3\2\2")
        buf.write("\2\u01be\u01c1\3\2\2\2\u01bf\u01bd\3\2\2\2\u01bf\u01c0")
        buf.write("\3\2\2\2\u01c0\u01c3\3\2\2\2\u01c1\u01bf\3\2\2\2\u01c2")
        buf.write("\u01b8\3\2\2\2\u01c2\u01c3\3\2\2\2\u01c3\u01c6\3\2\2\2")
        buf.write("\u01c4\u01c5\7c\2\2\u01c5\u01c7\t\2\2\2\u01c6\u01c4\3")
        buf.write("\2\2\2\u01c6\u01c7\3\2\2\2\u01c7\u01c9\3\2\2\2\u01c8\u01ca")
        buf.write("\5&\24\2\u01c9\u01c8\3\2\2\2\u01c9\u01ca\3\2\2\2\u01ca")
        buf.write("\u0214\3\2\2\2\u01cb\u01cd\7\u009b\2\2\u01cc\u01ce\5\"")
        buf.write("\22\2\u01cd\u01cc\3\2\2\2\u01cd\u01ce\3\2\2\2\u01ce\u01cf")
        buf.write("\3\2\2\2\u01cf\u01d4\5$\23\2\u01d0\u01d1\7\4\2\2\u01d1")
        buf.write("\u01d3\5$\23\2\u01d2\u01d0\3\2\2\2\u01d3\u01d6\3\2\2\2")
        buf.write("\u01d4\u01d2\3\2\2\2\u01d4\u01d5\3\2\2\2\u01d5\u01d8\3")
        buf.write("\2\2\2\u01d6\u01d4\3\2\2\2\u01d7\u01d9\5&\24\2\u01d8\u01d7")
        buf.write("\3\2\2\2\u01d8\u01d9\3\2\2\2\u01d9\u01da\3\2\2\2\u01da")
        buf.write("\u01db\7F\2\2\u01db\u01dc\7/\2\2\u01dc\u01dd\7\3\2\2\u01dd")
        buf.write("\u01de\5\22\n\2\u01de\u01df\7\5\2\2\u01df\u01e2\7v\2\2")
        buf.write("\u01e0\u01e3\5\64\33\2\u01e1\u01e3\7\u00d0\2\2\u01e2\u01e0")
        buf.write("\3\2\2\2\u01e2\u01e1\3\2\2\2\u01e3\u01f3\3\2\2\2\u01e4")
        buf.write("\u01f1\7\u00c3\2\2\u01e5\u01e7\5\30\r\2\u01e6\u01e5\3")
        buf.write("\2\2\2\u01e6\u01e7\3\2\2\2\u01e7\u01e9\3\2\2\2\u01e8\u01ea")
        buf.write("\5\32\16\2\u01e9\u01e8\3\2\2\2\u01e9\u01ea\3\2\2\2\u01ea")
        buf.write("\u01f2\3\2\2\2\u01eb\u01ed\5\32\16\2\u01ec\u01eb\3\2\2")
        buf.write("\2\u01ec\u01ed\3\2\2\2\u01ed\u01ef\3\2\2\2\u01ee\u01f0")
        buf.write("\5\30\r\2\u01ef\u01ee\3\2\2\2\u01ef\u01f0\3\2\2\2\u01f0")
        buf.write("\u01f2\3\2\2\2\u01f1\u01e6\3\2\2\2\u01f1\u01ec\3\2\2\2")
        buf.write("\u01f2\u01f4\3\2\2\2\u01f3\u01e4\3\2\2\2\u01f3\u01f4\3")
        buf.write("\2\2\2\u01f4\u01f8\3\2\2\2\u01f5\u01f6\7 \2\2\u01f6\u01f7")
        buf.write("\7\23\2\2\u01f7\u01f9\5\34\17\2\u01f8\u01f5\3\2\2\2\u01f8")
        buf.write("\u01f9\3\2\2\2\u01f9\u01fd\3\2\2\2\u01fa\u01fb\7g\2\2")
        buf.write("\u01fb\u01fc\7\34\2\2\u01fc\u01fe\7\u00d7\2\2\u01fd\u01fa")
        buf.write("\3\2\2\2\u01fd\u01fe\3\2\2\2\u01fe\u0201\3\2\2\2\u01ff")
        buf.write("\u0200\7\u00c2\2\2\u0200\u0202\5:\36\2\u0201\u01ff\3\2")
        buf.write("\2\2\u0201\u0202\3\2\2\2\u0202\u020d\3\2\2\2\u0203\u0204")
        buf.write("\7{\2\2\u0204\u0205\7\23\2\2\u0205\u020a\5\26\f\2\u0206")
        buf.write("\u0207\7\4\2\2\u0207\u0209\5\26\f\2\u0208\u0206\3\2\2")
        buf.write("\2\u0209\u020c\3\2\2\2\u020a\u0208\3\2\2\2\u020a\u020b")
        buf.write("\3\2\2\2\u020b\u020e\3\2\2\2\u020c\u020a\3\2\2\2\u020d")
        buf.write("\u0203\3\2\2\2\u020d\u020e\3\2\2\2\u020e\u0211\3\2\2\2")
        buf.write("\u020f\u0210\7c\2\2\u0210\u0212\t\2\2\2\u0211\u020f\3")
        buf.write("\2\2\2\u0211\u0212\3\2\2\2\u0212\u0214\3\2\2\2\u0213\u00e7")
        buf.write("\3\2\2\2\u0213\u0135\3\2\2\2\u0213\u0183\3\2\2\2\u0213")
        buf.write("\u01cb\3\2\2\2\u0214\21\3\2\2\2\u0215\u0216\7\u00a2\2")
        buf.write("\2\u0216\u0217\5,\27\2\u0217\u0218\7\u00c2\2\2\u0218\u0219")
        buf.write("\5:\36\2\u0219\u0220\3\2\2\2\u021a\u021b\7\u00a2\2\2\u021b")
        buf.write("\u021c\5\n\6\2\u021c\u021d\7\u00c2\2\2\u021d\u021e\5:")
        buf.write("\36\2\u021e\u0220\3\2\2\2\u021f\u0215\3\2\2\2\u021f\u021a")
        buf.write("\3\2\2\2\u0220\23\3\2\2\2\u0221\u0222\5X-\2\u0222\u0225")
        buf.write("\5L\'\2\u0223\u0224\7\35\2\2\u0224\u0226\5D#\2\u0225\u0223")
        buf.write("\3\2\2\2\u0225\u0226\3\2\2\2\u0226\25\3\2\2\2\u0227\u0229")
        buf.write("\58\35\2\u0228\u022a\t\3\2\2\u0229\u0228\3\2\2\2\u0229")
        buf.write("\u022a\3\2\2\2\u022a\u022d\3\2\2\2\u022b\u022c\7u\2\2")
        buf.write("\u022c\u022e\t\4\2\2\u022d\u022b\3\2\2\2\u022d\u022e\3")
        buf.write("\2\2\2\u022e\27\3\2\2\2\u022f\u0230\7h\2\2\u0230\u0231")
        buf.write("\7\u008a\2\2\u0231\u0232\7\u00d8\2\2\u0232\31\3\2\2\2")
        buf.write("\u0233\u0234\7i\2\2\u0234\u0235\7\u00d8\2\2\u0235\33\3")
        buf.write("\2\2\2\u0236\u0237\5X-\2\u0237\u0238\7\3\2\2\u0238\u0239")
        buf.write("\5\36\20\2\u0239\u023a\7\5\2\2\u023a\35\3\2\2\2\u023b")
        buf.write("\u023c\5 \21\2\u023c\u023d\7\3\2\2\u023d\u023e\7\u00d0")
        buf.write("\2\2\u023e\u023f\7\5\2\2\u023f\37\3\2\2\2\u0240\u0241")
        buf.write("\t\5\2\2\u0241!\3\2\2\2\u0242\u0243\t\6\2\2\u0243#\3\2")
        buf.write("\2\2\u0244\u0249\58\35\2\u0245\u0247\7\16\2\2\u0246\u0245")
        buf.write("\3\2\2\2\u0246\u0247\3\2\2\2\u0247\u0248\3\2\2\2\u0248")
        buf.write("\u024a\5X-\2\u0249\u0246\3\2\2\2\u0249\u024a\3\2\2\2\u024a")
        buf.write("\u0251\3\2\2\2\u024b\u024c\5V,\2\u024c\u024d\7\6\2\2\u024d")
        buf.write("\u024e\7\u00d0\2\2\u024e\u0251\3\2\2\2\u024f\u0251\7\u00d0")
        buf.write("\2\2\u0250\u0244\3\2\2\2\u0250\u024b\3\2\2\2\u0250\u024f")
        buf.write("\3\2\2\2\u0251%\3\2\2\2\u0252\u0253\7Z\2\2\u0253\u0254")
        buf.write("\7~\2\2\u0254\u0257\7\u00d4\2\2\u0255\u0256\t\7\2\2\u0256")
        buf.write("\u0258\5(\25\2\u0257\u0255\3\2\2\2\u0257\u0258\3\2\2\2")
        buf.write("\u0258\u025b\3\2\2\2\u0259\u025a\7d\2\2\u025a\u025c\5")
        buf.write("(\25\2\u025b\u0259\3\2\2\2\u025b\u025c\3\2\2\2\u025c\'")
        buf.write("\3\2\2\2\u025d\u025e\7\u00ac\2\2\u025e\u025f\7\23\2\2")
        buf.write("\u025f\u0260\7\u00d4\2\2\u0260)\3\2\2\2\u0261\u0262\7")
        buf.write("\67\2\2\u0262\u0263\7\23\2\2\u0263\u0264\7\u00d4\2\2\u0264")
        buf.write("+\3\2\2\2\u0265\u0266\b\27\1\2\u0266\u0267\5\62\32\2\u0267")
        buf.write("\u027a\3\2\2\2\u0268\u0276\f\3\2\2\u0269\u026a\7%\2\2")
        buf.write("\u026a\u026b\7]\2\2\u026b\u0277\5\62\32\2\u026c\u026d")
        buf.write("\5.\30\2\u026d\u026e\7]\2\2\u026e\u026f\5,\27\2\u026f")
        buf.write("\u0270\5\60\31\2\u0270\u0277\3\2\2\2\u0271\u0272\7l\2")
        buf.write("\2\u0272\u0273\5.\30\2\u0273\u0274\7]\2\2\u0274\u0275")
        buf.write("\5\62\32\2\u0275\u0277\3\2\2\2\u0276\u0269\3\2\2\2\u0276")
        buf.write("\u026c\3\2\2\2\u0276\u0271\3\2\2\2\u0277\u0279\3\2\2\2")
        buf.write("\u0278\u0268\3\2\2\2\u0279\u027c\3\2\2\2\u027a\u0278\3")
        buf.write("\2\2\2\u027a\u027b\3\2\2\2\u027b-\3\2\2\2\u027c\u027a")
        buf.write("\3\2\2\2\u027d\u027f\7T\2\2\u027e\u027d\3\2\2\2\u027e")
        buf.write("\u027f\3\2\2\2\u027f\u028d\3\2\2\2\u0280\u0282\7`\2\2")
        buf.write("\u0281\u0283\7}\2\2\u0282\u0281\3\2\2\2\u0282\u0283\3")
        buf.write("\2\2\2\u0283\u028d\3\2\2\2\u0284\u0286\7\u0093\2\2\u0285")
        buf.write("\u0287\7}\2\2\u0286\u0285\3\2\2\2\u0286\u0287\3\2\2\2")
        buf.write("\u0287\u028d\3\2\2\2\u0288\u028a\7G\2\2\u0289\u028b\7")
        buf.write("}\2\2\u028a\u0289\3\2\2\2\u028a\u028b\3\2\2\2\u028b\u028d")
        buf.write("\3\2\2\2\u028c\u027e\3\2\2\2\u028c\u0280\3\2\2\2\u028c")
        buf.write("\u0284\3\2\2\2\u028c\u0288\3\2\2\2\u028d/\3\2\2\2\u028e")
        buf.write("\u028f\7v\2\2\u028f\u029d\5:\36\2\u0290\u0291\7\u00bc")
        buf.write("\2\2\u0291\u0292\7\3\2\2\u0292\u0297\5X-\2\u0293\u0294")
        buf.write("\7\4\2\2\u0294\u0296\5X-\2\u0295\u0293\3\2\2\2\u0296\u0299")
        buf.write("\3\2\2\2\u0297\u0295\3\2\2\2\u0297\u0298\3\2\2\2\u0298")
        buf.write("\u029a\3\2\2\2\u0299\u0297\3\2\2\2\u029a\u029b\7\5\2\2")
        buf.write("\u029b\u029d\3\2\2\2\u029c\u028e\3\2\2\2\u029c\u0290\3")
        buf.write("\2\2\2\u029d\61\3\2\2\2\u029e\u02a9\5\66\34\2\u029f\u02a1")
        buf.write("\7\16\2\2\u02a0\u029f\3\2\2\2\u02a0\u02a1\3\2\2\2\u02a1")
        buf.write("\u02a2\3\2\2\2\u02a2\u02a7\5X-\2\u02a3\u02a4\7\3\2\2\u02a4")
        buf.write("\u02a5\5\64\33\2\u02a5\u02a6\7\5\2\2\u02a6\u02a8\3\2\2")
        buf.write("\2\u02a7\u02a3\3\2\2\2\u02a7\u02a8\3\2\2\2\u02a8\u02aa")
        buf.write("\3\2\2\2\u02a9\u02a0\3\2\2\2\u02a9\u02aa\3\2\2\2\u02aa")
        buf.write("\63\3\2\2\2\u02ab\u02b0\5X-\2\u02ac\u02ad\7\4\2\2\u02ad")
        buf.write("\u02af\5X-\2\u02ae\u02ac\3\2\2\2\u02af\u02b2\3\2\2\2\u02b0")
        buf.write("\u02ae\3\2\2\2\u02b0\u02b1\3\2\2\2\u02b1\65\3\2\2\2\u02b2")
        buf.write("\u02b0\3\2\2\2\u02b3\u02bd\5V,\2\u02b4\u02b5\7\3\2\2\u02b5")
        buf.write("\u02b6\5\b\5\2\u02b6\u02b7\7\5\2\2\u02b7\u02bd\3\2\2\2")
        buf.write("\u02b8\u02b9\7\3\2\2\u02b9\u02ba\5,\27\2\u02ba\u02bb\7")
        buf.write("\5\2\2\u02bb\u02bd\3\2\2\2\u02bc\u02b3\3\2\2\2\u02bc\u02b4")
        buf.write("\3\2\2\2\u02bc\u02b8\3\2\2\2\u02bd\67\3\2\2\2\u02be\u02bf")
        buf.write("\5:\36\2\u02bf9\3\2\2\2\u02c0\u02c1\b\36\1\2\u02c1\u02c5")
        buf.write("\5<\37\2\u02c2\u02c3\7r\2\2\u02c3\u02c5\5:\36\5\u02c4")
        buf.write("\u02c0\3\2\2\2\u02c4\u02c2\3\2\2\2\u02c5\u02ce\3\2\2\2")
        buf.write("\u02c6\u02c7\f\4\2\2\u02c7\u02c8\7\13\2\2\u02c8\u02cd")
        buf.write("\5:\36\5\u02c9\u02ca\f\3\2\2\u02ca\u02cb\7z\2\2\u02cb")
        buf.write("\u02cd\5:\36\4\u02cc\u02c6\3\2\2\2\u02cc\u02c9\3\2\2\2")
        buf.write("\u02cd\u02d0\3\2\2\2\u02ce\u02cc\3\2\2\2\u02ce\u02cf\3")
        buf.write("\2\2\2\u02cf;\3\2\2\2\u02d0\u02ce\3\2\2\2\u02d1\u02d3")
        buf.write("\5@!\2\u02d2\u02d4\5> \2\u02d3\u02d2\3\2\2\2\u02d3\u02d4")
        buf.write("\3\2\2\2\u02d4=\3\2\2\2\u02d5\u02d6\5F$\2\u02d6\u02d7")
        buf.write("\5@!\2\u02d7\u0313\3\2\2\2\u02d8\u02d9\5F$\2\u02d9\u02da")
        buf.write("\5H%\2\u02da\u02db\7\3\2\2\u02db\u02dc\5\b\5\2\u02dc\u02dd")
        buf.write("\7\5\2\2\u02dd\u0313\3\2\2\2\u02de\u02e0\7r\2\2\u02df")
        buf.write("\u02de\3\2\2\2\u02df\u02e0\3\2\2\2\u02e0\u02e1\3\2\2\2")
        buf.write("\u02e1\u02e2\7\22\2\2\u02e2\u02e3\5@!\2\u02e3\u02e4\7")
        buf.write("\13\2\2\u02e4\u02e5\5@!\2\u02e5\u0313\3\2\2\2\u02e6\u02e8")
        buf.write("\7r\2\2\u02e7\u02e6\3\2\2\2\u02e7\u02e8\3\2\2\2\u02e8")
        buf.write("\u02e9\3\2\2\2\u02e9\u02ea\7R\2\2\u02ea\u02eb\7\3\2\2")
        buf.write("\u02eb\u02f0\58\35\2\u02ec\u02ed\7\4\2\2\u02ed\u02ef\5")
        buf.write("8\35\2\u02ee\u02ec\3\2\2\2\u02ef\u02f2\3\2\2\2\u02f0\u02ee")
        buf.write("\3\2\2\2\u02f0\u02f1\3\2\2\2\u02f1\u02f3\3\2\2\2\u02f2")
        buf.write("\u02f0\3\2\2\2\u02f3\u02f4\7\5\2\2\u02f4\u0313\3\2\2\2")
        buf.write("\u02f5\u02f7\7r\2\2\u02f6\u02f5\3\2\2\2\u02f6\u02f7\3")
        buf.write("\2\2\2\u02f7\u02f8\3\2\2\2\u02f8\u02f9\7R\2\2\u02f9\u02fa")
        buf.write("\7\3\2\2\u02fa\u02fb\5\b\5\2\u02fb\u02fc\7\5\2\2\u02fc")
        buf.write("\u0313\3\2\2\2\u02fd\u02ff\7r\2\2\u02fe\u02fd\3\2\2\2")
        buf.write("\u02fe\u02ff\3\2\2\2\u02ff\u0300\3\2\2\2\u0300\u0301\7")
        buf.write("b\2\2\u0301\u0304\5@!\2\u0302\u0303\7\66\2\2\u0303\u0305")
        buf.write("\5@!\2\u0304\u0302\3\2\2\2\u0304\u0305\3\2\2\2\u0305\u0313")
        buf.write("\3\2\2\2\u0306\u0308\7[\2\2\u0307\u0309\7r\2\2\u0308\u0307")
        buf.write("\3\2\2\2\u0308\u0309\3\2\2\2\u0309\u030a\3\2\2\2\u030a")
        buf.write("\u0313\7s\2\2\u030b\u030d\7[\2\2\u030c\u030e\7r\2\2\u030d")
        buf.write("\u030c\3\2\2\2\u030d\u030e\3\2\2\2\u030e\u030f\3\2\2\2")
        buf.write("\u030f\u0310\7\60\2\2\u0310\u0311\7F\2\2\u0311\u0313\5")
        buf.write("@!\2\u0312\u02d5\3\2\2\2\u0312\u02d8\3\2\2\2\u0312\u02df")
        buf.write("\3\2\2\2\u0312\u02e7\3\2\2\2\u0312\u02f6\3\2\2\2\u0312")
        buf.write("\u02fe\3\2\2\2\u0312\u0306\3\2\2\2\u0312\u030b\3\2\2\2")
        buf.write("\u0313?\3\2\2\2\u0314\u0315\b!\1\2\u0315\u0319\5B\"\2")
        buf.write("\u0316\u0317\t\b\2\2\u0317\u0319\5@!\6\u0318\u0314\3\2")
        buf.write("\2\2\u0318\u0316\3\2\2\2\u0319\u0325\3\2\2\2\u031a\u031b")
        buf.write("\f\5\2\2\u031b\u031c\t\t\2\2\u031c\u0324\5@!\6\u031d\u031e")
        buf.write("\f\4\2\2\u031e\u031f\t\b\2\2\u031f\u0324\5@!\5\u0320\u0321")
        buf.write("\f\3\2\2\u0321\u0322\7\u00d3\2\2\u0322\u0324\5@!\4\u0323")
        buf.write("\u031a\3\2\2\2\u0323\u031d\3\2\2\2\u0323\u0320\3\2\2\2")
        buf.write("\u0324\u0327\3\2\2\2\u0325\u0323\3\2\2\2\u0325\u0326\3")
        buf.write("\2\2\2\u0326A\3\2\2\2\u0327\u0325\3\2\2\2\u0328\u0329")
        buf.write("\b\"\1\2\u0329\u035c\7s\2\2\u032a\u032b\5X-\2\u032b\u032c")
        buf.write("\5D#\2\u032c\u035c\3\2\2\2\u032d\u032e\7\u00df\2\2\u032e")
        buf.write("\u035c\5D#\2\u032f\u035c\5Z.\2\u0330\u035c\5J&\2\u0331")
        buf.write("\u035c\5D#\2\u0332\u035c\7\u00d6\2\2\u0333\u0334\5V,\2")
        buf.write("\u0334\u0335\7\3\2\2\u0335\u0336\7\u00d0\2\2\u0336\u0338")
        buf.write("\7\5\2\2\u0337\u0339\5T+\2\u0338\u0337\3\2\2\2\u0338\u0339")
        buf.write("\3\2\2\2\u0339\u035c\3\2\2\2\u033a\u033b\5V,\2\u033b\u0347")
        buf.write("\7\3\2\2\u033c\u033e\5\"\22\2\u033d\u033c\3\2\2\2\u033d")
        buf.write("\u033e\3\2\2\2\u033e\u033f\3\2\2\2\u033f\u0344\58\35\2")
        buf.write("\u0340\u0341\7\4\2\2\u0341\u0343\58\35\2\u0342\u0340\3")
        buf.write("\2\2\2\u0343\u0346\3\2\2\2\u0344\u0342\3\2\2\2\u0344\u0345")
        buf.write("\3\2\2\2\u0345\u0348\3\2\2\2\u0346\u0344\3\2\2\2\u0347")
        buf.write("\u033d\3\2\2\2\u0347\u0348\3\2\2\2\u0348\u0349\3\2\2\2")
        buf.write("\u0349\u034b\7\5\2\2\u034a\u034c\5T+\2\u034b\u034a\3\2")
        buf.write("\2\2\u034b\u034c\3\2\2\2\u034c\u035c\3\2\2\2\u034d\u034e")
        buf.write("\7\3\2\2\u034e\u034f\5\b\5\2\u034f\u0350\7\5\2\2\u0350")
        buf.write("\u035c\3\2\2\2\u0351\u0352\7;\2\2\u0352\u0353\7\3\2\2")
        buf.write("\u0353\u0354\5\b\5\2\u0354\u0355\7\5\2\2\u0355\u035c\3")
        buf.write("\2\2\2\u0356\u035c\5X-\2\u0357\u0358\7\3\2\2\u0358\u0359")
        buf.write("\58\35\2\u0359\u035a\7\5\2\2\u035a\u035c\3\2\2\2\u035b")
        buf.write("\u0328\3\2\2\2\u035b\u032a\3\2\2\2\u035b\u032d\3\2\2\2")
        buf.write("\u035b\u032f\3\2\2\2\u035b\u0330\3\2\2\2\u035b\u0331\3")
        buf.write("\2\2\2\u035b\u0332\3\2\2\2\u035b\u0333\3\2\2\2\u035b\u033a")
        buf.write("\3\2\2\2\u035b\u034d\3\2\2\2\u035b\u0351\3\2\2\2\u035b")
        buf.write("\u0356\3\2\2\2\u035b\u0357\3\2\2\2\u035c\u0362\3\2\2\2")
        buf.write("\u035d\u035e\f\4\2\2\u035e\u035f\7\6\2\2\u035f\u0361\5")
        buf.write("X-\2\u0360\u035d\3\2\2\2\u0361\u0364\3\2\2\2\u0362\u0360")
        buf.write("\3\2\2\2\u0362\u0363\3\2\2\2\u0363C\3\2\2\2\u0364\u0362")
        buf.write("\3\2\2\2\u0365\u036c\7\u00d4\2\2\u0366\u0369\7\u00d5\2")
        buf.write("\2\u0367\u0368\7\u00b6\2\2\u0368\u036a\7\u00d4\2\2\u0369")
        buf.write("\u0367\3\2\2\2\u0369\u036a\3\2\2\2\u036a\u036c\3\2\2\2")
        buf.write("\u036b\u0365\3\2\2\2\u036b\u0366\3\2\2\2\u036cE\3\2\2")
        buf.write("\2\u036d\u036e\t\n\2\2\u036eG\3\2\2\2\u036f\u0370\t\13")
        buf.write("\2\2\u0370I\3\2\2\2\u0371\u0372\t\f\2\2\u0372K\3\2\2\2")
        buf.write("\u0373\u0374\b\'\1\2\u0374\u0375\7\r\2\2\u0375\u0376\7")
        buf.write("\u00ca\2\2\u0376\u0377\5L\'\2\u0377\u0378\7\u00cc\2\2")
        buf.write("\u0378\u039e\3\2\2\2\u0379\u037a\7f\2\2\u037a\u037b\7")
        buf.write("\u00ca\2\2\u037b\u037c\5L\'\2\u037c\u037d\7\4\2\2\u037d")
        buf.write("\u037e\5L\'\2\u037e\u037f\7\u00cc\2\2\u037f\u039e\3\2")
        buf.write("\2\2\u0380\u0381\7\u0096\2\2\u0381\u0382\7\3\2\2\u0382")
        buf.write("\u0383\5X-\2\u0383\u038a\5L\'\2\u0384\u0385\7\4\2\2\u0385")
        buf.write("\u0386\5X-\2\u0386\u0387\5L\'\2\u0387\u0389\3\2\2\2\u0388")
        buf.write("\u0384\3\2\2\2\u0389\u038c\3\2\2\2\u038a\u0388\3\2\2\2")
        buf.write("\u038a\u038b\3\2\2\2\u038b\u038d\3\2\2\2\u038c\u038a\3")
        buf.write("\2\2\2\u038d\u038e\7\5\2\2\u038e\u039e\3\2\2\2\u038f\u039b")
        buf.write("\5P)\2\u0390\u0391\7\3\2\2\u0391\u0396\5N(\2\u0392\u0393")
        buf.write("\7\4\2\2\u0393\u0395\5N(\2\u0394\u0392\3\2\2\2\u0395\u0398")
        buf.write("\3\2\2\2\u0396\u0394\3\2\2\2\u0396\u0397\3\2\2\2\u0397")
        buf.write("\u0399\3\2\2\2\u0398\u0396\3\2\2\2\u0399\u039a\7\5\2\2")
        buf.write("\u039a\u039c\3\2\2\2\u039b\u0390\3\2\2\2\u039b\u039c\3")
        buf.write("\2\2\2\u039c\u039e\3\2\2\2\u039d\u0373\3\2\2\2\u039d\u0379")
        buf.write("\3\2\2\2\u039d\u0380\3\2\2\2\u039d\u038f\3\2\2\2\u039e")
        buf.write("\u03a3\3\2\2\2\u039f\u03a0\f\7\2\2\u03a0\u03a2\7\r\2\2")
        buf.write("\u03a1\u039f\3\2\2\2\u03a2\u03a5\3\2\2\2\u03a3\u03a1\3")
        buf.write("\2\2\2\u03a3\u03a4\3\2\2\2\u03a4M\3\2\2\2\u03a5\u03a3")
        buf.write("\3\2\2\2\u03a6\u03a9\7\u00d7\2\2\u03a7\u03a9\5L\'\2\u03a8")
        buf.write("\u03a6\3\2\2\2\u03a8\u03a7\3\2\2\2\u03a9O\3\2\2\2\u03aa")
        buf.write("\u03af\7\u00dd\2\2\u03ab\u03af\7\u00de\2\2\u03ac\u03af")
        buf.write("\7\u00df\2\2\u03ad\u03af\5X-\2\u03ae\u03aa\3\2\2\2\u03ae")
        buf.write("\u03ab\3\2\2\2\u03ae\u03ac\3\2\2\2\u03ae\u03ad\3\2\2\2")
        buf.write("\u03afQ\3\2\2\2\u03b0\u03b1\7\u00c1\2\2\u03b1\u03b2\5")
        buf.write("8\35\2\u03b2\u03b3\7\u00ae\2\2\u03b3\u03b4\58\35\2\u03b4")
        buf.write("S\3\2\2\2\u03b5\u03b6\7A\2\2\u03b6\u03b7\7\3\2\2\u03b7")
        buf.write("\u03b8\7\u00c2\2\2\u03b8\u03b9\5:\36\2\u03b9\u03ba\7\5")
        buf.write("\2\2\u03baU\3\2\2\2\u03bb\u03c0\5X-\2\u03bc\u03bd\7\6")
        buf.write("\2\2\u03bd\u03bf\5X-\2\u03be\u03bc\3\2\2\2\u03bf\u03c2")
        buf.write("\3\2\2\2\u03c0\u03be\3\2\2\2\u03c0\u03c1\3\2\2\2\u03c1")
        buf.write("W\3\2\2\2\u03c2\u03c0\3\2\2\2\u03c3\u03c8\7\u00d9\2\2")
        buf.write("\u03c4\u03c8\5\\/\2\u03c5\u03c8\7\u00dc\2\2\u03c6\u03c8")
        buf.write("\7\u00da\2\2\u03c7\u03c3\3\2\2\2\u03c7\u03c4\3\2\2\2\u03c7")
        buf.write("\u03c5\3\2\2\2\u03c7\u03c6\3\2\2\2\u03c8Y\3\2\2\2\u03c9")
        buf.write("\u03cc\7\u00d8\2\2\u03ca\u03cc\7\u00d7\2\2\u03cb\u03c9")
        buf.write("\3\2\2\2\u03cb\u03ca\3\2\2\2\u03cc[\3\2\2\2\u03cd\u03ce")
        buf.write("\t\r\2\2\u03ce]\3\2\2\2\u0098rwy\u0087\u008b\u0092\u009b")
        buf.write("\u009e\u00a2\u00ab\u00ae\u00b2\u00b5\u00b9\u00c0\u00c4")
        buf.write("\u00cc\u00cf\u00d3\u00dc\u00df\u00e3\u00e5\u00e9\u00f0")
        buf.write("\u00f7\u00fc\u0101\u0105\u0108\u010b\u010e\u0110\u0112")
        buf.write("\u0117\u011c\u0120\u0129\u012c\u0130\u0133\u0137\u013e")
        buf.write("\u0142\u0148\u014d\u0152\u0156\u0159\u015c\u015f\u0161")
        buf.write("\u0163\u0168\u016d\u0171\u017a\u017d\u0181\u0185\u018c")
        buf.write("\u0197\u019b\u019e\u01a1\u01a4\u01a6\u01a8\u01ad\u01b2")
        buf.write("\u01b6\u01bf\u01c2\u01c6\u01c9\u01cd\u01d4\u01d8\u01e2")
        buf.write("\u01e6\u01e9\u01ec\u01ef\u01f1\u01f3\u01f8\u01fd\u0201")
        buf.write("\u020a\u020d\u0211\u0213\u021f\u0225\u0229\u022d\u0246")
        buf.write("\u0249\u0250\u0257\u025b\u0276\u027a\u027e\u0282\u0286")
        buf.write("\u028a\u028c\u0297\u029c\u02a0\u02a7\u02a9\u02b0\u02bc")
        buf.write("\u02c4\u02cc\u02ce\u02d3\u02df\u02e7\u02f0\u02f6\u02fe")
        buf.write("\u0304\u0308\u030d\u0312\u0318\u0323\u0325\u0338\u033d")
        buf.write("\u0344\u0347\u034b\u035b\u0362\u0369\u036b\u038a\u0396")
        buf.write("\u039b\u039d\u03a3\u03a8\u03ae\u03c0\u03c7\u03cb")
        return buf.getvalue()


class SqlBaseParser ( Parser ):

    grammarFileName = "SqlBase.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'('", "','", "')'", "'.'", "'ADD'", "'ALL'", 
                     "'ALTER'", "'ANALYZE'", "'AND'", "'ANY'", "'ARRAY'", 
                     "'AS'", "'ASC'", "'AT'", "'BERNOULLI'", "'BETWEEN'", 
                     "'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'", 
                     "'CATALOGS'", "'COALESCE'", "'COLUMN'", "'COLUMNS'", 
                     "'COMBO'", "'COMMENT'", "'COMMIT'", "'COMMITTED'", 
                     "'COMPARE'", "'CONSTRAINT'", "'COUNT'", "'CREATE'", 
                     "'CSV'", "'CROSS'", "'CUBE'", "'CURRENT'", "'DATA'", 
                     "'DATE'", "'DAY'", "'DEALLOCATE'", "'DELETE'", "'DESC'", 
                     "'DESCRIBE'", "'DIFF'", "'DISTINCT'", "'DISTRIBUTED'", 
                     "'DROP'", "'ELSE'", "'ENCLOSED'", "'END'", "'ESCAPE'", 
                     "'ESCAPED'", "'EXCEPT'", "'EXCLUDING'", "'EXECUTE'", 
                     "'EXISTS'", "'EXPLAIN'", "'EXTRACT'", "'FALSE'", "'FIELDS'", 
                     "'FILE'", "'FILTER'", "'FIRST'", "'FOLLOWING'", "'FOR'", 
                     "'FORMAT'", "'FROM'", "'FULL'", "'FUNCTIONS'", "'GRANT'", 
                     "'GRANTS'", "'GRAPHVIZ'", "'GROUP'", "'GROUPING'", 
                     "'HAVING'", "'HOUR'", "'IF'", "'IMPORT'", "'IN'", "'INCLUDING'", 
                     "'INNER'", "'INPUT'", "'INSERT'", "'INTEGER'", "'INTERSECT'", 
                     "'INTERVAL'", "'INTO'", "'IS'", "'ISOLATION'", "'JOIN'", 
                     "'LAST'", "'LATERAL'", "'LEFT'", "'LEVEL'", "'LIKE'", 
                     "'LIMIT'", "'LINES'", "'LOGICAL'", "'MAP'", "'MAX'", 
                     "'MIN'", "'MIN SUPPORT'", "'MINUTE'", "'MONTH'", "'NATURAL'", 
                     "'NFC'", "'NFD'", "'NFKC'", "'NFKD'", "'NO'", "'NOT'", 
                     "'NULL'", "'NULLIF'", "'NULLS'", "'ON'", "'ONLY'", 
                     "'OPTION'", "'OPTIONALLY'", "'OR'", "'ORDER'", "'ORDINALITY'", 
                     "'OUTER'", "'OUTFILE'", "'OUTPUT'", "'OVER'", "'PARTITION'", 
                     "'PARTITIONS'", "'POSITION'", "'PRECEDING'", "'PREPARE'", 
                     "'PRIVILEGES'", "'PROPERTIES'", "'PUBLIC'", "'RANGE'", 
                     "'RATIO'", "'READ'", "'RECURSIVE'", "'RENAME'", "'REPEATABLE'", 
                     "'REPLACE'", "'RESET'", "'RESTRICT'", "'REVOKE'", "'RIGHT'", 
                     "'ROLLBACK'", "'ROLLUP'", "'ROW'", "'ROWS'", "'SCHEMA'", 
                     "'SCHEMAS'", "'SECOND'", "'SELECT'", "'SESSION'", "'SET'", 
                     "'SETS'", "'SHOW'", "'SMALLINT'", "'SOME'", "'SPLIT'", 
                     "'START'", "'STARTING'", "'STATS'", "'SUBSTRING'", 
                     "'SUM'", "'SYSTEM'", "'TABLE'", "'TABLES'", "'TABLESAMPLE'", 
                     "'TERMINATED'", "'TEXT'", "'THEN'", "'TIME'", "'TIMESTAMP'", 
                     "'TINYINT'", "'TO'", "'TRUE'", "'TRY_CAST'", "'TYPE'", 
                     "'UESCAPE'", "'UNBOUNDED'", "'UNCOMMITTED'", "'UNION'", 
                     "'UNNEST'", "'USE'", "'USING'", "'VALIDATE'", "'VALUES'", 
                     "'VERBOSE'", "'VIEW'", "'WHEN'", "'WHERE'", "'WITH'", 
                     "'WORK'", "'WRITE'", "'YEAR'", "'ZONE'", "'='", "<INVALID>", 
                     "'<'", "'<='", "'>'", "'>='", "'+'", "'-'", "'*'", 
                     "'/'", "'%'", "'||'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "ADD", "ALL", "ALTER", "ANALYZE", "AND", 
                      "ANY", "ARRAY", "AS", "ASC", "AT", "BERNOULLI", "BETWEEN", 
                      "BY", "CALL", "CASCADE", "CASE", "CAST", "CATALOGS", 
                      "COALESCE", "COLUMN", "COLUMNS", "COMBO", "COMMENT", 
                      "COMMIT", "COMMITTED", "COMPARE", "CONSTRAINT", "COUNT", 
                      "CREATE", "CSV", "CROSS", "CUBE", "CURRENT", "DATA", 
                      "DATE", "DAY", "DEALLOCATE", "DELETE", "DESC", "DESCRIBE", 
                      "DIFF", "DISTINCT", "DISTRIBUTED", "DROP", "ELSE", 
                      "ENCLOSED", "END", "ESCAPE", "ESCAPED", "EXCEPT", 
                      "EXCLUDING", "EXECUTE", "EXISTS", "EXPLAIN", "EXTRACT", 
                      "FALSE", "FIELDS", "FILE", "FILTER", "FIRST", "FOLLOWING", 
                      "FOR", "FORMAT", "FROM", "FULL", "FUNCTIONS", "GRANT", 
                      "GRANTS", "GRAPHVIZ", "GROUP", "GROUPING", "HAVING", 
                      "HOUR", "IF", "IMPORT", "IN", "INCLUDING", "INNER", 
                      "INPUT", "INSERT", "INTEGER", "INTERSECT", "INTERVAL", 
                      "INTO", "IS", "ISOLATION", "JOIN", "LAST", "LATERAL", 
                      "LEFT", "LEVEL", "LIKE", "LIMIT", "LINES", "LOGICAL", 
                      "MAP", "MAX", "MIN", "MIN_SUPPORT", "MINUTE", "MONTH", 
                      "NATURAL", "NFC", "NFD", "NFKC", "NFKD", "NO", "NOT", 
                      "NULL", "NULLIF", "NULLS", "ON", "ONLY", "OPTION", 
                      "OPTIONALLY", "OR", "ORDER", "ORDINALITY", "OUTER", 
                      "OUTFILE", "OUTPUT", "OVER", "PARTITION", "PARTITIONS", 
                      "POSITION", "PRECEDING", "PREPARE", "PRIVILEGES", 
                      "PROPERTIES", "PUBLIC", "RANGE", "RATIO", "READ", 
                      "RECURSIVE", "RENAME", "REPEATABLE", "REPLACE", "RESET", 
                      "RESTRICT", "REVOKE", "RIGHT", "ROLLBACK", "ROLLUP", 
                      "ROW", "ROWS", "SCHEMA", "SCHEMAS", "SECOND", "SELECT", 
                      "SESSION", "SET", "SETS", "SHOW", "SMALLINT", "SOME", 
                      "SPLIT", "START", "STARTING", "STATS", "SUBSTRING", 
                      "SUM", "SYSTEM", "TABLE", "TABLES", "TABLESAMPLE", 
                      "TERMINATED", "TEXT", "THEN", "TIME", "TIMESTAMP", 
                      "TINYINT", "TO", "TRUE", "TRY_CAST", "TYPE", "UESCAPE", 
                      "UNBOUNDED", "UNCOMMITTED", "UNION", "UNNEST", "USE", 
                      "USING", "VALIDATE", "VALUES", "VERBOSE", "VIEW", 
                      "WHEN", "WHERE", "WITH", "WORK", "WRITE", "YEAR", 
                      "ZONE", "EQ", "NEQ", "LT", "LTE", "GT", "GTE", "PLUS", 
                      "MINUS", "ASTERISK", "SLASH", "PERCENT", "CONCAT", 
                      "STRING", "UNICODE_STRING", "BINARY_LITERAL", "INTEGER_VALUE", 
                      "DECIMAL_VALUE", "IDENTIFIER", "DIGIT_IDENTIFIER", 
                      "QUOTED_IDENTIFIER", "BACKQUOTED_IDENTIFIER", "TIME_WITH_TIME_ZONE", 
                      "TIMESTAMP_WITH_TIME_ZONE", "DOUBLE_PRECISION", "SIMPLE_COMMENT", 
                      "BRACKETED_COMMENT", "WS", "UNRECOGNIZED", "DELIMITER" ]

    RULE_singleStatement = 0
    RULE_singleExpression = 1
    RULE_statement = 2
    RULE_query = 3
    RULE_queryTerm = 4
    RULE_queryPrimary = 5
    RULE_querySpecification = 6
    RULE_diffQuerySpecification = 7
    RULE_splitQuery = 8
    RULE_columnDefinition = 9
    RULE_sortItem = 10
    RULE_minRatioExpression = 11
    RULE_minSupportExpression = 12
    RULE_ratioMetricExpression = 13
    RULE_aggregateExpression = 14
    RULE_aggregate = 15
    RULE_setQuantifier = 16
    RULE_selectItem = 17
    RULE_exportClause = 18
    RULE_delimiterClause = 19
    RULE_escapeClause = 20
    RULE_relation = 21
    RULE_joinType = 22
    RULE_joinCriteria = 23
    RULE_aliasedRelation = 24
    RULE_columnAliases = 25
    RULE_relationPrimary = 26
    RULE_expression = 27
    RULE_booleanExpression = 28
    RULE_predicated = 29
    RULE_predicate = 30
    RULE_valueExpression = 31
    RULE_primaryExpression = 32
    RULE_string = 33
    RULE_comparisonOperator = 34
    RULE_comparisonQuantifier = 35
    RULE_booleanValue = 36
    RULE_type = 37
    RULE_typeParameter = 38
    RULE_baseType = 39
    RULE_whenClause = 40
    RULE_filter = 41
    RULE_qualifiedName = 42
    RULE_identifier = 43
    RULE_number = 44
    RULE_nonReserved = 45

    ruleNames =  [ "singleStatement", "singleExpression", "statement", "query", 
                   "queryTerm", "queryPrimary", "querySpecification", "diffQuerySpecification", 
                   "splitQuery", "columnDefinition", "sortItem", "minRatioExpression", 
                   "minSupportExpression", "ratioMetricExpression", "aggregateExpression", 
                   "aggregate", "setQuantifier", "selectItem", "exportClause", 
                   "delimiterClause", "escapeClause", "relation", "joinType", 
                   "joinCriteria", "aliasedRelation", "columnAliases", "relationPrimary", 
                   "expression", "booleanExpression", "predicated", "predicate", 
                   "valueExpression", "primaryExpression", "string", "comparisonOperator", 
                   "comparisonQuantifier", "booleanValue", "type", "typeParameter", 
                   "baseType", "whenClause", "filter", "qualifiedName", 
                   "identifier", "number", "nonReserved" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    ADD=5
    ALL=6
    ALTER=7
    ANALYZE=8
    AND=9
    ANY=10
    ARRAY=11
    AS=12
    ASC=13
    AT=14
    BERNOULLI=15
    BETWEEN=16
    BY=17
    CALL=18
    CASCADE=19
    CASE=20
    CAST=21
    CATALOGS=22
    COALESCE=23
    COLUMN=24
    COLUMNS=25
    COMBO=26
    COMMENT=27
    COMMIT=28
    COMMITTED=29
    COMPARE=30
    CONSTRAINT=31
    COUNT=32
    CREATE=33
    CSV=34
    CROSS=35
    CUBE=36
    CURRENT=37
    DATA=38
    DATE=39
    DAY=40
    DEALLOCATE=41
    DELETE=42
    DESC=43
    DESCRIBE=44
    DIFF=45
    DISTINCT=46
    DISTRIBUTED=47
    DROP=48
    ELSE=49
    ENCLOSED=50
    END=51
    ESCAPE=52
    ESCAPED=53
    EXCEPT=54
    EXCLUDING=55
    EXECUTE=56
    EXISTS=57
    EXPLAIN=58
    EXTRACT=59
    FALSE=60
    FIELDS=61
    FILE=62
    FILTER=63
    FIRST=64
    FOLLOWING=65
    FOR=66
    FORMAT=67
    FROM=68
    FULL=69
    FUNCTIONS=70
    GRANT=71
    GRANTS=72
    GRAPHVIZ=73
    GROUP=74
    GROUPING=75
    HAVING=76
    HOUR=77
    IF=78
    IMPORT=79
    IN=80
    INCLUDING=81
    INNER=82
    INPUT=83
    INSERT=84
    INTEGER=85
    INTERSECT=86
    INTERVAL=87
    INTO=88
    IS=89
    ISOLATION=90
    JOIN=91
    LAST=92
    LATERAL=93
    LEFT=94
    LEVEL=95
    LIKE=96
    LIMIT=97
    LINES=98
    LOGICAL=99
    MAP=100
    MAX=101
    MIN=102
    MIN_SUPPORT=103
    MINUTE=104
    MONTH=105
    NATURAL=106
    NFC=107
    NFD=108
    NFKC=109
    NFKD=110
    NO=111
    NOT=112
    NULL=113
    NULLIF=114
    NULLS=115
    ON=116
    ONLY=117
    OPTION=118
    OPTIONALLY=119
    OR=120
    ORDER=121
    ORDINALITY=122
    OUTER=123
    OUTFILE=124
    OUTPUT=125
    OVER=126
    PARTITION=127
    PARTITIONS=128
    POSITION=129
    PRECEDING=130
    PREPARE=131
    PRIVILEGES=132
    PROPERTIES=133
    PUBLIC=134
    RANGE=135
    RATIO=136
    READ=137
    RECURSIVE=138
    RENAME=139
    REPEATABLE=140
    REPLACE=141
    RESET=142
    RESTRICT=143
    REVOKE=144
    RIGHT=145
    ROLLBACK=146
    ROLLUP=147
    ROW=148
    ROWS=149
    SCHEMA=150
    SCHEMAS=151
    SECOND=152
    SELECT=153
    SESSION=154
    SET=155
    SETS=156
    SHOW=157
    SMALLINT=158
    SOME=159
    SPLIT=160
    START=161
    STARTING=162
    STATS=163
    SUBSTRING=164
    SUM=165
    SYSTEM=166
    TABLE=167
    TABLES=168
    TABLESAMPLE=169
    TERMINATED=170
    TEXT=171
    THEN=172
    TIME=173
    TIMESTAMP=174
    TINYINT=175
    TO=176
    TRUE=177
    TRY_CAST=178
    TYPE=179
    UESCAPE=180
    UNBOUNDED=181
    UNCOMMITTED=182
    UNION=183
    UNNEST=184
    USE=185
    USING=186
    VALIDATE=187
    VALUES=188
    VERBOSE=189
    VIEW=190
    WHEN=191
    WHERE=192
    WITH=193
    WORK=194
    WRITE=195
    YEAR=196
    ZONE=197
    EQ=198
    NEQ=199
    LT=200
    LTE=201
    GT=202
    GTE=203
    PLUS=204
    MINUS=205
    ASTERISK=206
    SLASH=207
    PERCENT=208
    CONCAT=209
    STRING=210
    UNICODE_STRING=211
    BINARY_LITERAL=212
    INTEGER_VALUE=213
    DECIMAL_VALUE=214
    IDENTIFIER=215
    DIGIT_IDENTIFIER=216
    QUOTED_IDENTIFIER=217
    BACKQUOTED_IDENTIFIER=218
    TIME_WITH_TIME_ZONE=219
    TIMESTAMP_WITH_TIME_ZONE=220
    DOUBLE_PRECISION=221
    SIMPLE_COMMENT=222
    BRACKETED_COMMENT=223
    WS=224
    UNRECOGNIZED=225
    DELIMITER=226

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class SingleStatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(SqlBaseParser.StatementContext,0)


        def EOF(self):
            return self.getToken(SqlBaseParser.EOF, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_singleStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleStatement" ):
                listener.enterSingleStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleStatement" ):
                listener.exitSingleStatement(self)




    def singleStatement(self):

        localctx = SqlBaseParser.SingleStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_singleStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 92
            self.statement()
            self.state = 93
            self.match(SqlBaseParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)


        def EOF(self):
            return self.getToken(SqlBaseParser.EOF, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_singleExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleExpression" ):
                listener.enterSingleExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleExpression" ):
                listener.exitSingleExpression(self)




    def singleExpression(self):

        localctx = SqlBaseParser.SingleExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_singleExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 95
            self.expression()
            self.state = 96
            self.match(SqlBaseParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ImportCsvContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IMPORT(self):
            return self.getToken(SqlBaseParser.IMPORT, 0)
        def FROM(self):
            return self.getToken(SqlBaseParser.FROM, 0)
        def CSV(self):
            return self.getToken(SqlBaseParser.CSV, 0)
        def FILE(self):
            return self.getToken(SqlBaseParser.FILE, 0)
        def STRING(self):
            return self.getToken(SqlBaseParser.STRING, 0)
        def INTO(self):
            return self.getToken(SqlBaseParser.INTO, 0)
        def qualifiedName(self):
            return self.getTypedRuleContext(SqlBaseParser.QualifiedNameContext,0)

        def columnDefinition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ColumnDefinitionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ColumnDefinitionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportCsv" ):
                listener.enterImportCsv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportCsv" ):
                listener.exitImportCsv(self)


    class StatementDefaultContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatementDefault" ):
                listener.enterStatementDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatementDefault" ):
                listener.exitStatementDefault(self)



    def statement(self):

        localctx = SqlBaseParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_statement)
        self._la = 0 # Token type
        try:
            self.state = 119
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlBaseParser.T__0, SqlBaseParser.SELECT, SqlBaseParser.TABLE]:
                localctx = SqlBaseParser.StatementDefaultContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 98
                self.query()
                pass
            elif token in [SqlBaseParser.IMPORT]:
                localctx = SqlBaseParser.ImportCsvContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 99
                self.match(SqlBaseParser.IMPORT)
                self.state = 100
                self.match(SqlBaseParser.FROM)
                self.state = 101
                self.match(SqlBaseParser.CSV)
                self.state = 102
                self.match(SqlBaseParser.FILE)
                self.state = 103
                self.match(SqlBaseParser.STRING)
                self.state = 104
                self.match(SqlBaseParser.INTO)
                self.state = 105
                self.qualifiedName()
                self.state = 117
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.T__0:
                    self.state = 106
                    self.match(SqlBaseParser.T__0)
                    self.state = 107
                    self.columnDefinition()
                    self.state = 112
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==SqlBaseParser.T__1:
                        self.state = 108
                        self.match(SqlBaseParser.T__1)
                        self.state = 109
                        self.columnDefinition()
                        self.state = 114
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 115
                    self.match(SqlBaseParser.T__2)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def queryTerm(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryTermContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuery" ):
                listener.enterQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuery" ):
                listener.exitQuery(self)




    def query(self):

        localctx = SqlBaseParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_query)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.queryTerm()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryTermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_queryTerm

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class QueryTermDefaultContext(QueryTermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.QueryTermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def queryPrimary(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryPrimaryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryTermDefault" ):
                listener.enterQueryTermDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryTermDefault" ):
                listener.exitQueryTermDefault(self)



    def queryTerm(self):

        localctx = SqlBaseParser.QueryTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_queryTerm)
        try:
            localctx = SqlBaseParser.QueryTermDefaultContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.queryPrimary()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryPrimaryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_queryPrimary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SubqueryContext(QueryPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.QueryPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubquery" ):
                listener.enterSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubquery" ):
                listener.exitSubquery(self)


    class QueryPrimaryDefaultContext(QueryPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.QueryPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def querySpecification(self):
            return self.getTypedRuleContext(SqlBaseParser.QuerySpecificationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryPrimaryDefault" ):
                listener.enterQueryPrimaryDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryPrimaryDefault" ):
                listener.exitQueryPrimaryDefault(self)


    class TableContext(QueryPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.QueryPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TABLE(self):
            return self.getToken(SqlBaseParser.TABLE, 0)
        def qualifiedName(self):
            return self.getTypedRuleContext(SqlBaseParser.QualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable" ):
                listener.enterTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable" ):
                listener.exitTable(self)


    class DiffQueryContext(QueryPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.QueryPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def diffQuerySpecification(self):
            return self.getTypedRuleContext(SqlBaseParser.DiffQuerySpecificationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiffQuery" ):
                listener.enterDiffQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiffQuery" ):
                listener.exitDiffQuery(self)



    def queryPrimary(self):

        localctx = SqlBaseParser.QueryPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_queryPrimary)
        try:
            self.state = 133
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.QueryPrimaryDefaultContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 125
                self.querySpecification()
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.DiffQueryContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 126
                self.diffQuerySpecification()
                pass

            elif la_ == 3:
                localctx = SqlBaseParser.TableContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 127
                self.match(SqlBaseParser.TABLE)
                self.state = 128
                self.qualifiedName()
                pass

            elif la_ == 4:
                localctx = SqlBaseParser.SubqueryContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 129
                self.match(SqlBaseParser.T__0)
                self.state = 130
                self.query()
                self.state = 131
                self.match(SqlBaseParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuerySpecificationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.where = None # BooleanExpressionContext
            self.limit = None # Token

        def SELECT(self):
            return self.getToken(SqlBaseParser.SELECT, 0)

        def selectItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.SelectItemContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.SelectItemContext,i)


        def setQuantifier(self):
            return self.getTypedRuleContext(SqlBaseParser.SetQuantifierContext,0)


        def FROM(self):
            return self.getToken(SqlBaseParser.FROM, 0)

        def relation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.RelationContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.RelationContext,i)


        def WHERE(self):
            return self.getToken(SqlBaseParser.WHERE, 0)

        def ORDER(self):
            return self.getToken(SqlBaseParser.ORDER, 0)

        def BY(self):
            return self.getToken(SqlBaseParser.BY, 0)

        def sortItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.SortItemContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.SortItemContext,i)


        def LIMIT(self):
            return self.getToken(SqlBaseParser.LIMIT, 0)

        def exportClause(self):
            return self.getTypedRuleContext(SqlBaseParser.ExportClauseContext,0)


        def booleanExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,0)


        def INTEGER_VALUE(self):
            return self.getToken(SqlBaseParser.INTEGER_VALUE, 0)

        def ALL(self):
            return self.getToken(SqlBaseParser.ALL, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_querySpecification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuerySpecification" ):
                listener.enterQuerySpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuerySpecification" ):
                listener.exitQuerySpecification(self)




    def querySpecification(self):

        localctx = SqlBaseParser.QuerySpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_querySpecification)
        self._la = 0 # Token type
        try:
            self.state = 227
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 135
                self.match(SqlBaseParser.SELECT)
                self.state = 137
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                if la_ == 1:
                    self.state = 136
                    self.setQuantifier()


                self.state = 139
                self.selectItem()
                self.state = 144
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 140
                        self.match(SqlBaseParser.T__1)
                        self.state = 141
                        self.selectItem() 
                    self.state = 146
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

                self.state = 156
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.FROM:
                    self.state = 147
                    self.match(SqlBaseParser.FROM)
                    self.state = 148
                    self.relation(0)
                    self.state = 153
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 149
                            self.match(SqlBaseParser.T__1)
                            self.state = 150
                            self.relation(0) 
                        self.state = 155
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,6,self._ctx)



                self.state = 160
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
                if la_ == 1:
                    self.state = 158
                    self.match(SqlBaseParser.WHERE)
                    self.state = 159
                    localctx.where = self.booleanExpression(0)


                self.state = 172
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.ORDER:
                    self.state = 162
                    self.match(SqlBaseParser.ORDER)
                    self.state = 163
                    self.match(SqlBaseParser.BY)
                    self.state = 164
                    self.sortItem()
                    self.state = 169
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 165
                            self.match(SqlBaseParser.T__1)
                            self.state = 166
                            self.sortItem() 
                        self.state = 171
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,9,self._ctx)



                self.state = 176
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
                if la_ == 1:
                    self.state = 174
                    self.match(SqlBaseParser.LIMIT)
                    self.state = 175
                    localctx.limit = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==SqlBaseParser.ALL or _la==SqlBaseParser.INTEGER_VALUE):
                        localctx.limit = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 179
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.INTO:
                    self.state = 178
                    self.exportClause()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 181
                self.match(SqlBaseParser.SELECT)
                self.state = 183
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
                if la_ == 1:
                    self.state = 182
                    self.setQuantifier()


                self.state = 185
                self.selectItem()
                self.state = 190
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,14,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 186
                        self.match(SqlBaseParser.T__1)
                        self.state = 187
                        self.selectItem() 
                    self.state = 192
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

                self.state = 194
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.INTO:
                    self.state = 193
                    self.exportClause()


                self.state = 205
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.FROM:
                    self.state = 196
                    self.match(SqlBaseParser.FROM)
                    self.state = 197
                    self.relation(0)
                    self.state = 202
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 198
                            self.match(SqlBaseParser.T__1)
                            self.state = 199
                            self.relation(0) 
                        self.state = 204
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,16,self._ctx)



                self.state = 209
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
                if la_ == 1:
                    self.state = 207
                    self.match(SqlBaseParser.WHERE)
                    self.state = 208
                    localctx.where = self.booleanExpression(0)


                self.state = 221
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.ORDER:
                    self.state = 211
                    self.match(SqlBaseParser.ORDER)
                    self.state = 212
                    self.match(SqlBaseParser.BY)
                    self.state = 213
                    self.sortItem()
                    self.state = 218
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 214
                            self.match(SqlBaseParser.T__1)
                            self.state = 215
                            self.sortItem() 
                        self.state = 220
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,19,self._ctx)



                self.state = 225
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
                if la_ == 1:
                    self.state = 223
                    self.match(SqlBaseParser.LIMIT)
                    self.state = 224
                    localctx.limit = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==SqlBaseParser.ALL or _la==SqlBaseParser.INTEGER_VALUE):
                        localctx.limit = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DiffQuerySpecificationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.maxCombo = None # Token
            self.where = None # BooleanExpressionContext
            self.limit = None # Token

        def SELECT(self):
            return self.getToken(SqlBaseParser.SELECT, 0)

        def selectItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.SelectItemContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.SelectItemContext,i)


        def FROM(self):
            return self.getToken(SqlBaseParser.FROM, 0)

        def DIFF(self):
            return self.getToken(SqlBaseParser.DIFF, 0)

        def queryTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.QueryTermContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.QueryTermContext,i)


        def ON(self):
            return self.getToken(SqlBaseParser.ON, 0)

        def columnAliases(self):
            return self.getTypedRuleContext(SqlBaseParser.ColumnAliasesContext,0)


        def ASTERISK(self):
            return self.getToken(SqlBaseParser.ASTERISK, 0)

        def setQuantifier(self):
            return self.getTypedRuleContext(SqlBaseParser.SetQuantifierContext,0)


        def qualifiedName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.QualifiedNameContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.QualifiedNameContext,i)


        def WITH(self):
            return self.getToken(SqlBaseParser.WITH, 0)

        def COMPARE(self):
            return self.getToken(SqlBaseParser.COMPARE, 0)

        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(SqlBaseParser.BY)
            else:
                return self.getToken(SqlBaseParser.BY, i)

        def ratioMetricExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.RatioMetricExpressionContext,0)


        def MAX(self):
            return self.getToken(SqlBaseParser.MAX, 0)

        def COMBO(self):
            return self.getToken(SqlBaseParser.COMBO, 0)

        def WHERE(self):
            return self.getToken(SqlBaseParser.WHERE, 0)

        def ORDER(self):
            return self.getToken(SqlBaseParser.ORDER, 0)

        def sortItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.SortItemContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.SortItemContext,i)


        def LIMIT(self):
            return self.getToken(SqlBaseParser.LIMIT, 0)

        def exportClause(self):
            return self.getTypedRuleContext(SqlBaseParser.ExportClauseContext,0)


        def INTEGER_VALUE(self, i:int=None):
            if i is None:
                return self.getTokens(SqlBaseParser.INTEGER_VALUE)
            else:
                return self.getToken(SqlBaseParser.INTEGER_VALUE, i)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,0)


        def ALL(self):
            return self.getToken(SqlBaseParser.ALL, 0)

        def minRatioExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.MinRatioExpressionContext,0)


        def minSupportExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.MinSupportExpressionContext,0)


        def splitQuery(self):
            return self.getTypedRuleContext(SqlBaseParser.SplitQueryContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_diffQuerySpecification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiffQuerySpecification" ):
                listener.enterDiffQuerySpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiffQuerySpecification" ):
                listener.exitDiffQuerySpecification(self)




    def diffQuerySpecification(self):

        localctx = SqlBaseParser.DiffQuerySpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_diffQuerySpecification)
        self._la = 0 # Token type
        try:
            self.state = 529
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 229
                self.match(SqlBaseParser.SELECT)
                self.state = 231
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
                if la_ == 1:
                    self.state = 230
                    self.setQuantifier()


                self.state = 233
                self.selectItem()
                self.state = 238
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SqlBaseParser.T__1:
                    self.state = 234
                    self.match(SqlBaseParser.T__1)
                    self.state = 235
                    self.selectItem()
                    self.state = 240
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 241
                self.match(SqlBaseParser.FROM)
                self.state = 242
                self.match(SqlBaseParser.DIFF)
                self.state = 243
                self.queryTerm()
                self.state = 245
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SqlBaseParser.ADD) | (1 << SqlBaseParser.ALL) | (1 << SqlBaseParser.ANALYZE) | (1 << SqlBaseParser.ANY) | (1 << SqlBaseParser.ARRAY) | (1 << SqlBaseParser.ASC) | (1 << SqlBaseParser.AT) | (1 << SqlBaseParser.BERNOULLI) | (1 << SqlBaseParser.CALL) | (1 << SqlBaseParser.CASCADE) | (1 << SqlBaseParser.CATALOGS) | (1 << SqlBaseParser.COALESCE) | (1 << SqlBaseParser.COLUMN) | (1 << SqlBaseParser.COLUMNS) | (1 << SqlBaseParser.COMMENT) | (1 << SqlBaseParser.COMMIT) | (1 << SqlBaseParser.COMMITTED) | (1 << SqlBaseParser.CURRENT) | (1 << SqlBaseParser.DATA) | (1 << SqlBaseParser.DATE) | (1 << SqlBaseParser.DAY) | (1 << SqlBaseParser.DESC) | (1 << SqlBaseParser.DISTRIBUTED) | (1 << SqlBaseParser.EXCLUDING) | (1 << SqlBaseParser.EXPLAIN) | (1 << SqlBaseParser.FILTER))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (SqlBaseParser.FIRST - 64)) | (1 << (SqlBaseParser.FOLLOWING - 64)) | (1 << (SqlBaseParser.FORMAT - 64)) | (1 << (SqlBaseParser.FUNCTIONS - 64)) | (1 << (SqlBaseParser.GRANT - 64)) | (1 << (SqlBaseParser.GRANTS - 64)) | (1 << (SqlBaseParser.GRAPHVIZ - 64)) | (1 << (SqlBaseParser.HOUR - 64)) | (1 << (SqlBaseParser.IF - 64)) | (1 << (SqlBaseParser.INCLUDING - 64)) | (1 << (SqlBaseParser.INPUT - 64)) | (1 << (SqlBaseParser.INTEGER - 64)) | (1 << (SqlBaseParser.INTERVAL - 64)) | (1 << (SqlBaseParser.ISOLATION - 64)) | (1 << (SqlBaseParser.LAST - 64)) | (1 << (SqlBaseParser.LATERAL - 64)) | (1 << (SqlBaseParser.LEVEL - 64)) | (1 << (SqlBaseParser.LIMIT - 64)) | (1 << (SqlBaseParser.LOGICAL - 64)) | (1 << (SqlBaseParser.MAP - 64)) | (1 << (SqlBaseParser.MINUTE - 64)) | (1 << (SqlBaseParser.MONTH - 64)) | (1 << (SqlBaseParser.NFC - 64)) | (1 << (SqlBaseParser.NFD - 64)) | (1 << (SqlBaseParser.NFKC - 64)) | (1 << (SqlBaseParser.NFKD - 64)) | (1 << (SqlBaseParser.NO - 64)) | (1 << (SqlBaseParser.NULLIF - 64)) | (1 << (SqlBaseParser.NULLS - 64)) | (1 << (SqlBaseParser.ONLY - 64)) | (1 << (SqlBaseParser.OPTION - 64)) | (1 << (SqlBaseParser.ORDINALITY - 64)) | (1 << (SqlBaseParser.OUTPUT - 64)) | (1 << (SqlBaseParser.OVER - 64)) | (1 << (SqlBaseParser.PARTITION - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (SqlBaseParser.PARTITIONS - 128)) | (1 << (SqlBaseParser.POSITION - 128)) | (1 << (SqlBaseParser.PRECEDING - 128)) | (1 << (SqlBaseParser.PRIVILEGES - 128)) | (1 << (SqlBaseParser.PROPERTIES - 128)) | (1 << (SqlBaseParser.PUBLIC - 128)) | (1 << (SqlBaseParser.RANGE - 128)) | (1 << (SqlBaseParser.READ - 128)) | (1 << (SqlBaseParser.RENAME - 128)) | (1 << (SqlBaseParser.REPEATABLE - 128)) | (1 << (SqlBaseParser.REPLACE - 128)) | (1 << (SqlBaseParser.RESET - 128)) | (1 << (SqlBaseParser.RESTRICT - 128)) | (1 << (SqlBaseParser.REVOKE - 128)) | (1 << (SqlBaseParser.ROLLBACK - 128)) | (1 << (SqlBaseParser.ROW - 128)) | (1 << (SqlBaseParser.ROWS - 128)) | (1 << (SqlBaseParser.SCHEMA - 128)) | (1 << (SqlBaseParser.SCHEMAS - 128)) | (1 << (SqlBaseParser.SECOND - 128)) | (1 << (SqlBaseParser.SESSION - 128)) | (1 << (SqlBaseParser.SET - 128)) | (1 << (SqlBaseParser.SETS - 128)) | (1 << (SqlBaseParser.SHOW - 128)) | (1 << (SqlBaseParser.SMALLINT - 128)) | (1 << (SqlBaseParser.SOME - 128)) | (1 << (SqlBaseParser.START - 128)) | (1 << (SqlBaseParser.STATS - 128)) | (1 << (SqlBaseParser.SUBSTRING - 128)) | (1 << (SqlBaseParser.SYSTEM - 128)) | (1 << (SqlBaseParser.TABLES - 128)) | (1 << (SqlBaseParser.TABLESAMPLE - 128)) | (1 << (SqlBaseParser.TEXT - 128)) | (1 << (SqlBaseParser.TIME - 128)) | (1 << (SqlBaseParser.TIMESTAMP - 128)) | (1 << (SqlBaseParser.TINYINT - 128)) | (1 << (SqlBaseParser.TO - 128)) | (1 << (SqlBaseParser.TRY_CAST - 128)) | (1 << (SqlBaseParser.TYPE - 128)) | (1 << (SqlBaseParser.UNBOUNDED - 128)) | (1 << (SqlBaseParser.UNCOMMITTED - 128)) | (1 << (SqlBaseParser.USE - 128)) | (1 << (SqlBaseParser.VALIDATE - 128)) | (1 << (SqlBaseParser.VERBOSE - 128)) | (1 << (SqlBaseParser.VIEW - 128)))) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & ((1 << (SqlBaseParser.WORK - 194)) | (1 << (SqlBaseParser.WRITE - 194)) | (1 << (SqlBaseParser.YEAR - 194)) | (1 << (SqlBaseParser.ZONE - 194)) | (1 << (SqlBaseParser.IDENTIFIER - 194)) | (1 << (SqlBaseParser.DIGIT_IDENTIFIER - 194)) | (1 << (SqlBaseParser.BACKQUOTED_IDENTIFIER - 194)))) != 0):
                    self.state = 244
                    self.qualifiedName()


                self.state = 247
                self.match(SqlBaseParser.T__1)
                self.state = 248
                self.queryTerm()
                self.state = 250
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SqlBaseParser.ADD) | (1 << SqlBaseParser.ALL) | (1 << SqlBaseParser.ANALYZE) | (1 << SqlBaseParser.ANY) | (1 << SqlBaseParser.ARRAY) | (1 << SqlBaseParser.ASC) | (1 << SqlBaseParser.AT) | (1 << SqlBaseParser.BERNOULLI) | (1 << SqlBaseParser.CALL) | (1 << SqlBaseParser.CASCADE) | (1 << SqlBaseParser.CATALOGS) | (1 << SqlBaseParser.COALESCE) | (1 << SqlBaseParser.COLUMN) | (1 << SqlBaseParser.COLUMNS) | (1 << SqlBaseParser.COMMENT) | (1 << SqlBaseParser.COMMIT) | (1 << SqlBaseParser.COMMITTED) | (1 << SqlBaseParser.CURRENT) | (1 << SqlBaseParser.DATA) | (1 << SqlBaseParser.DATE) | (1 << SqlBaseParser.DAY) | (1 << SqlBaseParser.DESC) | (1 << SqlBaseParser.DISTRIBUTED) | (1 << SqlBaseParser.EXCLUDING) | (1 << SqlBaseParser.EXPLAIN) | (1 << SqlBaseParser.FILTER))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (SqlBaseParser.FIRST - 64)) | (1 << (SqlBaseParser.FOLLOWING - 64)) | (1 << (SqlBaseParser.FORMAT - 64)) | (1 << (SqlBaseParser.FUNCTIONS - 64)) | (1 << (SqlBaseParser.GRANT - 64)) | (1 << (SqlBaseParser.GRANTS - 64)) | (1 << (SqlBaseParser.GRAPHVIZ - 64)) | (1 << (SqlBaseParser.HOUR - 64)) | (1 << (SqlBaseParser.IF - 64)) | (1 << (SqlBaseParser.INCLUDING - 64)) | (1 << (SqlBaseParser.INPUT - 64)) | (1 << (SqlBaseParser.INTEGER - 64)) | (1 << (SqlBaseParser.INTERVAL - 64)) | (1 << (SqlBaseParser.ISOLATION - 64)) | (1 << (SqlBaseParser.LAST - 64)) | (1 << (SqlBaseParser.LATERAL - 64)) | (1 << (SqlBaseParser.LEVEL - 64)) | (1 << (SqlBaseParser.LIMIT - 64)) | (1 << (SqlBaseParser.LOGICAL - 64)) | (1 << (SqlBaseParser.MAP - 64)) | (1 << (SqlBaseParser.MINUTE - 64)) | (1 << (SqlBaseParser.MONTH - 64)) | (1 << (SqlBaseParser.NFC - 64)) | (1 << (SqlBaseParser.NFD - 64)) | (1 << (SqlBaseParser.NFKC - 64)) | (1 << (SqlBaseParser.NFKD - 64)) | (1 << (SqlBaseParser.NO - 64)) | (1 << (SqlBaseParser.NULLIF - 64)) | (1 << (SqlBaseParser.NULLS - 64)) | (1 << (SqlBaseParser.ONLY - 64)) | (1 << (SqlBaseParser.OPTION - 64)) | (1 << (SqlBaseParser.ORDINALITY - 64)) | (1 << (SqlBaseParser.OUTPUT - 64)) | (1 << (SqlBaseParser.OVER - 64)) | (1 << (SqlBaseParser.PARTITION - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (SqlBaseParser.PARTITIONS - 128)) | (1 << (SqlBaseParser.POSITION - 128)) | (1 << (SqlBaseParser.PRECEDING - 128)) | (1 << (SqlBaseParser.PRIVILEGES - 128)) | (1 << (SqlBaseParser.PROPERTIES - 128)) | (1 << (SqlBaseParser.PUBLIC - 128)) | (1 << (SqlBaseParser.RANGE - 128)) | (1 << (SqlBaseParser.READ - 128)) | (1 << (SqlBaseParser.RENAME - 128)) | (1 << (SqlBaseParser.REPEATABLE - 128)) | (1 << (SqlBaseParser.REPLACE - 128)) | (1 << (SqlBaseParser.RESET - 128)) | (1 << (SqlBaseParser.RESTRICT - 128)) | (1 << (SqlBaseParser.REVOKE - 128)) | (1 << (SqlBaseParser.ROLLBACK - 128)) | (1 << (SqlBaseParser.ROW - 128)) | (1 << (SqlBaseParser.ROWS - 128)) | (1 << (SqlBaseParser.SCHEMA - 128)) | (1 << (SqlBaseParser.SCHEMAS - 128)) | (1 << (SqlBaseParser.SECOND - 128)) | (1 << (SqlBaseParser.SESSION - 128)) | (1 << (SqlBaseParser.SET - 128)) | (1 << (SqlBaseParser.SETS - 128)) | (1 << (SqlBaseParser.SHOW - 128)) | (1 << (SqlBaseParser.SMALLINT - 128)) | (1 << (SqlBaseParser.SOME - 128)) | (1 << (SqlBaseParser.START - 128)) | (1 << (SqlBaseParser.STATS - 128)) | (1 << (SqlBaseParser.SUBSTRING - 128)) | (1 << (SqlBaseParser.SYSTEM - 128)) | (1 << (SqlBaseParser.TABLES - 128)) | (1 << (SqlBaseParser.TABLESAMPLE - 128)) | (1 << (SqlBaseParser.TEXT - 128)) | (1 << (SqlBaseParser.TIME - 128)) | (1 << (SqlBaseParser.TIMESTAMP - 128)) | (1 << (SqlBaseParser.TINYINT - 128)) | (1 << (SqlBaseParser.TO - 128)) | (1 << (SqlBaseParser.TRY_CAST - 128)) | (1 << (SqlBaseParser.TYPE - 128)) | (1 << (SqlBaseParser.UNBOUNDED - 128)) | (1 << (SqlBaseParser.UNCOMMITTED - 128)) | (1 << (SqlBaseParser.USE - 128)) | (1 << (SqlBaseParser.VALIDATE - 128)) | (1 << (SqlBaseParser.VERBOSE - 128)) | (1 << (SqlBaseParser.VIEW - 128)))) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & ((1 << (SqlBaseParser.WORK - 194)) | (1 << (SqlBaseParser.WRITE - 194)) | (1 << (SqlBaseParser.YEAR - 194)) | (1 << (SqlBaseParser.ZONE - 194)) | (1 << (SqlBaseParser.IDENTIFIER - 194)) | (1 << (SqlBaseParser.DIGIT_IDENTIFIER - 194)) | (1 << (SqlBaseParser.BACKQUOTED_IDENTIFIER - 194)))) != 0):
                    self.state = 249
                    self.qualifiedName()


                self.state = 252
                self.match(SqlBaseParser.ON)
                self.state = 255
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [SqlBaseParser.ADD, SqlBaseParser.ALL, SqlBaseParser.ANALYZE, SqlBaseParser.ANY, SqlBaseParser.ARRAY, SqlBaseParser.ASC, SqlBaseParser.AT, SqlBaseParser.BERNOULLI, SqlBaseParser.CALL, SqlBaseParser.CASCADE, SqlBaseParser.CATALOGS, SqlBaseParser.COALESCE, SqlBaseParser.COLUMN, SqlBaseParser.COLUMNS, SqlBaseParser.COMMENT, SqlBaseParser.COMMIT, SqlBaseParser.COMMITTED, SqlBaseParser.CURRENT, SqlBaseParser.DATA, SqlBaseParser.DATE, SqlBaseParser.DAY, SqlBaseParser.DESC, SqlBaseParser.DISTRIBUTED, SqlBaseParser.EXCLUDING, SqlBaseParser.EXPLAIN, SqlBaseParser.FILTER, SqlBaseParser.FIRST, SqlBaseParser.FOLLOWING, SqlBaseParser.FORMAT, SqlBaseParser.FUNCTIONS, SqlBaseParser.GRANT, SqlBaseParser.GRANTS, SqlBaseParser.GRAPHVIZ, SqlBaseParser.HOUR, SqlBaseParser.IF, SqlBaseParser.INCLUDING, SqlBaseParser.INPUT, SqlBaseParser.INTEGER, SqlBaseParser.INTERVAL, SqlBaseParser.ISOLATION, SqlBaseParser.LAST, SqlBaseParser.LATERAL, SqlBaseParser.LEVEL, SqlBaseParser.LIMIT, SqlBaseParser.LOGICAL, SqlBaseParser.MAP, SqlBaseParser.MINUTE, SqlBaseParser.MONTH, SqlBaseParser.NFC, SqlBaseParser.NFD, SqlBaseParser.NFKC, SqlBaseParser.NFKD, SqlBaseParser.NO, SqlBaseParser.NULLIF, SqlBaseParser.NULLS, SqlBaseParser.ONLY, SqlBaseParser.OPTION, SqlBaseParser.ORDINALITY, SqlBaseParser.OUTPUT, SqlBaseParser.OVER, SqlBaseParser.PARTITION, SqlBaseParser.PARTITIONS, SqlBaseParser.POSITION, SqlBaseParser.PRECEDING, SqlBaseParser.PRIVILEGES, SqlBaseParser.PROPERTIES, SqlBaseParser.PUBLIC, SqlBaseParser.RANGE, SqlBaseParser.READ, SqlBaseParser.RENAME, SqlBaseParser.REPEATABLE, SqlBaseParser.REPLACE, SqlBaseParser.RESET, SqlBaseParser.RESTRICT, SqlBaseParser.REVOKE, SqlBaseParser.ROLLBACK, SqlBaseParser.ROW, SqlBaseParser.ROWS, SqlBaseParser.SCHEMA, SqlBaseParser.SCHEMAS, SqlBaseParser.SECOND, SqlBaseParser.SESSION, SqlBaseParser.SET, SqlBaseParser.SETS, SqlBaseParser.SHOW, SqlBaseParser.SMALLINT, SqlBaseParser.SOME, SqlBaseParser.START, SqlBaseParser.STATS, SqlBaseParser.SUBSTRING, SqlBaseParser.SYSTEM, SqlBaseParser.TABLES, SqlBaseParser.TABLESAMPLE, SqlBaseParser.TEXT, SqlBaseParser.TIME, SqlBaseParser.TIMESTAMP, SqlBaseParser.TINYINT, SqlBaseParser.TO, SqlBaseParser.TRY_CAST, SqlBaseParser.TYPE, SqlBaseParser.UNBOUNDED, SqlBaseParser.UNCOMMITTED, SqlBaseParser.USE, SqlBaseParser.VALIDATE, SqlBaseParser.VERBOSE, SqlBaseParser.VIEW, SqlBaseParser.WORK, SqlBaseParser.WRITE, SqlBaseParser.YEAR, SqlBaseParser.ZONE, SqlBaseParser.IDENTIFIER, SqlBaseParser.DIGIT_IDENTIFIER, SqlBaseParser.BACKQUOTED_IDENTIFIER]:
                    self.state = 253
                    self.columnAliases()
                    pass
                elif token in [SqlBaseParser.ASTERISK]:
                    self.state = 254
                    self.match(SqlBaseParser.ASTERISK)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 272
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.WITH:
                    self.state = 257
                    self.match(SqlBaseParser.WITH)
                    self.state = 270
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
                    if la_ == 1:
                        self.state = 259
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN:
                            self.state = 258
                            self.minRatioExpression()


                        self.state = 262
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN_SUPPORT:
                            self.state = 261
                            self.minSupportExpression()


                        pass

                    elif la_ == 2:
                        self.state = 265
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN_SUPPORT:
                            self.state = 264
                            self.minSupportExpression()


                        self.state = 268
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN:
                            self.state = 267
                            self.minRatioExpression()


                        pass




                self.state = 277
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.COMPARE:
                    self.state = 274
                    self.match(SqlBaseParser.COMPARE)
                    self.state = 275
                    self.match(SqlBaseParser.BY)
                    self.state = 276
                    self.ratioMetricExpression()


                self.state = 282
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.MAX:
                    self.state = 279
                    self.match(SqlBaseParser.MAX)
                    self.state = 280
                    self.match(SqlBaseParser.COMBO)
                    self.state = 281
                    localctx.maxCombo = self.match(SqlBaseParser.INTEGER_VALUE)


                self.state = 286
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
                if la_ == 1:
                    self.state = 284
                    self.match(SqlBaseParser.WHERE)
                    self.state = 285
                    localctx.where = self.booleanExpression(0)


                self.state = 298
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.ORDER:
                    self.state = 288
                    self.match(SqlBaseParser.ORDER)
                    self.state = 289
                    self.match(SqlBaseParser.BY)
                    self.state = 290
                    self.sortItem()
                    self.state = 295
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,37,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 291
                            self.match(SqlBaseParser.T__1)
                            self.state = 292
                            self.sortItem() 
                        self.state = 297
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,37,self._ctx)



                self.state = 302
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
                if la_ == 1:
                    self.state = 300
                    self.match(SqlBaseParser.LIMIT)
                    self.state = 301
                    localctx.limit = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==SqlBaseParser.ALL or _la==SqlBaseParser.INTEGER_VALUE):
                        localctx.limit = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 305
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.INTO:
                    self.state = 304
                    self.exportClause()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 307
                self.match(SqlBaseParser.SELECT)
                self.state = 309
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
                if la_ == 1:
                    self.state = 308
                    self.setQuantifier()


                self.state = 311
                self.selectItem()
                self.state = 316
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SqlBaseParser.T__1:
                    self.state = 312
                    self.match(SqlBaseParser.T__1)
                    self.state = 313
                    self.selectItem()
                    self.state = 318
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 320
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.INTO:
                    self.state = 319
                    self.exportClause()


                self.state = 322
                self.match(SqlBaseParser.FROM)
                self.state = 323
                self.match(SqlBaseParser.DIFF)
                self.state = 324
                self.queryTerm()
                self.state = 326
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SqlBaseParser.ADD) | (1 << SqlBaseParser.ALL) | (1 << SqlBaseParser.ANALYZE) | (1 << SqlBaseParser.ANY) | (1 << SqlBaseParser.ARRAY) | (1 << SqlBaseParser.ASC) | (1 << SqlBaseParser.AT) | (1 << SqlBaseParser.BERNOULLI) | (1 << SqlBaseParser.CALL) | (1 << SqlBaseParser.CASCADE) | (1 << SqlBaseParser.CATALOGS) | (1 << SqlBaseParser.COALESCE) | (1 << SqlBaseParser.COLUMN) | (1 << SqlBaseParser.COLUMNS) | (1 << SqlBaseParser.COMMENT) | (1 << SqlBaseParser.COMMIT) | (1 << SqlBaseParser.COMMITTED) | (1 << SqlBaseParser.CURRENT) | (1 << SqlBaseParser.DATA) | (1 << SqlBaseParser.DATE) | (1 << SqlBaseParser.DAY) | (1 << SqlBaseParser.DESC) | (1 << SqlBaseParser.DISTRIBUTED) | (1 << SqlBaseParser.EXCLUDING) | (1 << SqlBaseParser.EXPLAIN) | (1 << SqlBaseParser.FILTER))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (SqlBaseParser.FIRST - 64)) | (1 << (SqlBaseParser.FOLLOWING - 64)) | (1 << (SqlBaseParser.FORMAT - 64)) | (1 << (SqlBaseParser.FUNCTIONS - 64)) | (1 << (SqlBaseParser.GRANT - 64)) | (1 << (SqlBaseParser.GRANTS - 64)) | (1 << (SqlBaseParser.GRAPHVIZ - 64)) | (1 << (SqlBaseParser.HOUR - 64)) | (1 << (SqlBaseParser.IF - 64)) | (1 << (SqlBaseParser.INCLUDING - 64)) | (1 << (SqlBaseParser.INPUT - 64)) | (1 << (SqlBaseParser.INTEGER - 64)) | (1 << (SqlBaseParser.INTERVAL - 64)) | (1 << (SqlBaseParser.ISOLATION - 64)) | (1 << (SqlBaseParser.LAST - 64)) | (1 << (SqlBaseParser.LATERAL - 64)) | (1 << (SqlBaseParser.LEVEL - 64)) | (1 << (SqlBaseParser.LIMIT - 64)) | (1 << (SqlBaseParser.LOGICAL - 64)) | (1 << (SqlBaseParser.MAP - 64)) | (1 << (SqlBaseParser.MINUTE - 64)) | (1 << (SqlBaseParser.MONTH - 64)) | (1 << (SqlBaseParser.NFC - 64)) | (1 << (SqlBaseParser.NFD - 64)) | (1 << (SqlBaseParser.NFKC - 64)) | (1 << (SqlBaseParser.NFKD - 64)) | (1 << (SqlBaseParser.NO - 64)) | (1 << (SqlBaseParser.NULLIF - 64)) | (1 << (SqlBaseParser.NULLS - 64)) | (1 << (SqlBaseParser.ONLY - 64)) | (1 << (SqlBaseParser.OPTION - 64)) | (1 << (SqlBaseParser.ORDINALITY - 64)) | (1 << (SqlBaseParser.OUTPUT - 64)) | (1 << (SqlBaseParser.OVER - 64)) | (1 << (SqlBaseParser.PARTITION - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (SqlBaseParser.PARTITIONS - 128)) | (1 << (SqlBaseParser.POSITION - 128)) | (1 << (SqlBaseParser.PRECEDING - 128)) | (1 << (SqlBaseParser.PRIVILEGES - 128)) | (1 << (SqlBaseParser.PROPERTIES - 128)) | (1 << (SqlBaseParser.PUBLIC - 128)) | (1 << (SqlBaseParser.RANGE - 128)) | (1 << (SqlBaseParser.READ - 128)) | (1 << (SqlBaseParser.RENAME - 128)) | (1 << (SqlBaseParser.REPEATABLE - 128)) | (1 << (SqlBaseParser.REPLACE - 128)) | (1 << (SqlBaseParser.RESET - 128)) | (1 << (SqlBaseParser.RESTRICT - 128)) | (1 << (SqlBaseParser.REVOKE - 128)) | (1 << (SqlBaseParser.ROLLBACK - 128)) | (1 << (SqlBaseParser.ROW - 128)) | (1 << (SqlBaseParser.ROWS - 128)) | (1 << (SqlBaseParser.SCHEMA - 128)) | (1 << (SqlBaseParser.SCHEMAS - 128)) | (1 << (SqlBaseParser.SECOND - 128)) | (1 << (SqlBaseParser.SESSION - 128)) | (1 << (SqlBaseParser.SET - 128)) | (1 << (SqlBaseParser.SETS - 128)) | (1 << (SqlBaseParser.SHOW - 128)) | (1 << (SqlBaseParser.SMALLINT - 128)) | (1 << (SqlBaseParser.SOME - 128)) | (1 << (SqlBaseParser.START - 128)) | (1 << (SqlBaseParser.STATS - 128)) | (1 << (SqlBaseParser.SUBSTRING - 128)) | (1 << (SqlBaseParser.SYSTEM - 128)) | (1 << (SqlBaseParser.TABLES - 128)) | (1 << (SqlBaseParser.TABLESAMPLE - 128)) | (1 << (SqlBaseParser.TEXT - 128)) | (1 << (SqlBaseParser.TIME - 128)) | (1 << (SqlBaseParser.TIMESTAMP - 128)) | (1 << (SqlBaseParser.TINYINT - 128)) | (1 << (SqlBaseParser.TO - 128)) | (1 << (SqlBaseParser.TRY_CAST - 128)) | (1 << (SqlBaseParser.TYPE - 128)) | (1 << (SqlBaseParser.UNBOUNDED - 128)) | (1 << (SqlBaseParser.UNCOMMITTED - 128)) | (1 << (SqlBaseParser.USE - 128)) | (1 << (SqlBaseParser.VALIDATE - 128)) | (1 << (SqlBaseParser.VERBOSE - 128)) | (1 << (SqlBaseParser.VIEW - 128)))) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & ((1 << (SqlBaseParser.WORK - 194)) | (1 << (SqlBaseParser.WRITE - 194)) | (1 << (SqlBaseParser.YEAR - 194)) | (1 << (SqlBaseParser.ZONE - 194)) | (1 << (SqlBaseParser.IDENTIFIER - 194)) | (1 << (SqlBaseParser.DIGIT_IDENTIFIER - 194)) | (1 << (SqlBaseParser.BACKQUOTED_IDENTIFIER - 194)))) != 0):
                    self.state = 325
                    self.qualifiedName()


                self.state = 328
                self.match(SqlBaseParser.T__1)
                self.state = 329
                self.queryTerm()
                self.state = 331
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SqlBaseParser.ADD) | (1 << SqlBaseParser.ALL) | (1 << SqlBaseParser.ANALYZE) | (1 << SqlBaseParser.ANY) | (1 << SqlBaseParser.ARRAY) | (1 << SqlBaseParser.ASC) | (1 << SqlBaseParser.AT) | (1 << SqlBaseParser.BERNOULLI) | (1 << SqlBaseParser.CALL) | (1 << SqlBaseParser.CASCADE) | (1 << SqlBaseParser.CATALOGS) | (1 << SqlBaseParser.COALESCE) | (1 << SqlBaseParser.COLUMN) | (1 << SqlBaseParser.COLUMNS) | (1 << SqlBaseParser.COMMENT) | (1 << SqlBaseParser.COMMIT) | (1 << SqlBaseParser.COMMITTED) | (1 << SqlBaseParser.CURRENT) | (1 << SqlBaseParser.DATA) | (1 << SqlBaseParser.DATE) | (1 << SqlBaseParser.DAY) | (1 << SqlBaseParser.DESC) | (1 << SqlBaseParser.DISTRIBUTED) | (1 << SqlBaseParser.EXCLUDING) | (1 << SqlBaseParser.EXPLAIN) | (1 << SqlBaseParser.FILTER))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (SqlBaseParser.FIRST - 64)) | (1 << (SqlBaseParser.FOLLOWING - 64)) | (1 << (SqlBaseParser.FORMAT - 64)) | (1 << (SqlBaseParser.FUNCTIONS - 64)) | (1 << (SqlBaseParser.GRANT - 64)) | (1 << (SqlBaseParser.GRANTS - 64)) | (1 << (SqlBaseParser.GRAPHVIZ - 64)) | (1 << (SqlBaseParser.HOUR - 64)) | (1 << (SqlBaseParser.IF - 64)) | (1 << (SqlBaseParser.INCLUDING - 64)) | (1 << (SqlBaseParser.INPUT - 64)) | (1 << (SqlBaseParser.INTEGER - 64)) | (1 << (SqlBaseParser.INTERVAL - 64)) | (1 << (SqlBaseParser.ISOLATION - 64)) | (1 << (SqlBaseParser.LAST - 64)) | (1 << (SqlBaseParser.LATERAL - 64)) | (1 << (SqlBaseParser.LEVEL - 64)) | (1 << (SqlBaseParser.LIMIT - 64)) | (1 << (SqlBaseParser.LOGICAL - 64)) | (1 << (SqlBaseParser.MAP - 64)) | (1 << (SqlBaseParser.MINUTE - 64)) | (1 << (SqlBaseParser.MONTH - 64)) | (1 << (SqlBaseParser.NFC - 64)) | (1 << (SqlBaseParser.NFD - 64)) | (1 << (SqlBaseParser.NFKC - 64)) | (1 << (SqlBaseParser.NFKD - 64)) | (1 << (SqlBaseParser.NO - 64)) | (1 << (SqlBaseParser.NULLIF - 64)) | (1 << (SqlBaseParser.NULLS - 64)) | (1 << (SqlBaseParser.ONLY - 64)) | (1 << (SqlBaseParser.OPTION - 64)) | (1 << (SqlBaseParser.ORDINALITY - 64)) | (1 << (SqlBaseParser.OUTPUT - 64)) | (1 << (SqlBaseParser.OVER - 64)) | (1 << (SqlBaseParser.PARTITION - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (SqlBaseParser.PARTITIONS - 128)) | (1 << (SqlBaseParser.POSITION - 128)) | (1 << (SqlBaseParser.PRECEDING - 128)) | (1 << (SqlBaseParser.PRIVILEGES - 128)) | (1 << (SqlBaseParser.PROPERTIES - 128)) | (1 << (SqlBaseParser.PUBLIC - 128)) | (1 << (SqlBaseParser.RANGE - 128)) | (1 << (SqlBaseParser.READ - 128)) | (1 << (SqlBaseParser.RENAME - 128)) | (1 << (SqlBaseParser.REPEATABLE - 128)) | (1 << (SqlBaseParser.REPLACE - 128)) | (1 << (SqlBaseParser.RESET - 128)) | (1 << (SqlBaseParser.RESTRICT - 128)) | (1 << (SqlBaseParser.REVOKE - 128)) | (1 << (SqlBaseParser.ROLLBACK - 128)) | (1 << (SqlBaseParser.ROW - 128)) | (1 << (SqlBaseParser.ROWS - 128)) | (1 << (SqlBaseParser.SCHEMA - 128)) | (1 << (SqlBaseParser.SCHEMAS - 128)) | (1 << (SqlBaseParser.SECOND - 128)) | (1 << (SqlBaseParser.SESSION - 128)) | (1 << (SqlBaseParser.SET - 128)) | (1 << (SqlBaseParser.SETS - 128)) | (1 << (SqlBaseParser.SHOW - 128)) | (1 << (SqlBaseParser.SMALLINT - 128)) | (1 << (SqlBaseParser.SOME - 128)) | (1 << (SqlBaseParser.START - 128)) | (1 << (SqlBaseParser.STATS - 128)) | (1 << (SqlBaseParser.SUBSTRING - 128)) | (1 << (SqlBaseParser.SYSTEM - 128)) | (1 << (SqlBaseParser.TABLES - 128)) | (1 << (SqlBaseParser.TABLESAMPLE - 128)) | (1 << (SqlBaseParser.TEXT - 128)) | (1 << (SqlBaseParser.TIME - 128)) | (1 << (SqlBaseParser.TIMESTAMP - 128)) | (1 << (SqlBaseParser.TINYINT - 128)) | (1 << (SqlBaseParser.TO - 128)) | (1 << (SqlBaseParser.TRY_CAST - 128)) | (1 << (SqlBaseParser.TYPE - 128)) | (1 << (SqlBaseParser.UNBOUNDED - 128)) | (1 << (SqlBaseParser.UNCOMMITTED - 128)) | (1 << (SqlBaseParser.USE - 128)) | (1 << (SqlBaseParser.VALIDATE - 128)) | (1 << (SqlBaseParser.VERBOSE - 128)) | (1 << (SqlBaseParser.VIEW - 128)))) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & ((1 << (SqlBaseParser.WORK - 194)) | (1 << (SqlBaseParser.WRITE - 194)) | (1 << (SqlBaseParser.YEAR - 194)) | (1 << (SqlBaseParser.ZONE - 194)) | (1 << (SqlBaseParser.IDENTIFIER - 194)) | (1 << (SqlBaseParser.DIGIT_IDENTIFIER - 194)) | (1 << (SqlBaseParser.BACKQUOTED_IDENTIFIER - 194)))) != 0):
                    self.state = 330
                    self.qualifiedName()


                self.state = 333
                self.match(SqlBaseParser.ON)
                self.state = 336
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [SqlBaseParser.ADD, SqlBaseParser.ALL, SqlBaseParser.ANALYZE, SqlBaseParser.ANY, SqlBaseParser.ARRAY, SqlBaseParser.ASC, SqlBaseParser.AT, SqlBaseParser.BERNOULLI, SqlBaseParser.CALL, SqlBaseParser.CASCADE, SqlBaseParser.CATALOGS, SqlBaseParser.COALESCE, SqlBaseParser.COLUMN, SqlBaseParser.COLUMNS, SqlBaseParser.COMMENT, SqlBaseParser.COMMIT, SqlBaseParser.COMMITTED, SqlBaseParser.CURRENT, SqlBaseParser.DATA, SqlBaseParser.DATE, SqlBaseParser.DAY, SqlBaseParser.DESC, SqlBaseParser.DISTRIBUTED, SqlBaseParser.EXCLUDING, SqlBaseParser.EXPLAIN, SqlBaseParser.FILTER, SqlBaseParser.FIRST, SqlBaseParser.FOLLOWING, SqlBaseParser.FORMAT, SqlBaseParser.FUNCTIONS, SqlBaseParser.GRANT, SqlBaseParser.GRANTS, SqlBaseParser.GRAPHVIZ, SqlBaseParser.HOUR, SqlBaseParser.IF, SqlBaseParser.INCLUDING, SqlBaseParser.INPUT, SqlBaseParser.INTEGER, SqlBaseParser.INTERVAL, SqlBaseParser.ISOLATION, SqlBaseParser.LAST, SqlBaseParser.LATERAL, SqlBaseParser.LEVEL, SqlBaseParser.LIMIT, SqlBaseParser.LOGICAL, SqlBaseParser.MAP, SqlBaseParser.MINUTE, SqlBaseParser.MONTH, SqlBaseParser.NFC, SqlBaseParser.NFD, SqlBaseParser.NFKC, SqlBaseParser.NFKD, SqlBaseParser.NO, SqlBaseParser.NULLIF, SqlBaseParser.NULLS, SqlBaseParser.ONLY, SqlBaseParser.OPTION, SqlBaseParser.ORDINALITY, SqlBaseParser.OUTPUT, SqlBaseParser.OVER, SqlBaseParser.PARTITION, SqlBaseParser.PARTITIONS, SqlBaseParser.POSITION, SqlBaseParser.PRECEDING, SqlBaseParser.PRIVILEGES, SqlBaseParser.PROPERTIES, SqlBaseParser.PUBLIC, SqlBaseParser.RANGE, SqlBaseParser.READ, SqlBaseParser.RENAME, SqlBaseParser.REPEATABLE, SqlBaseParser.REPLACE, SqlBaseParser.RESET, SqlBaseParser.RESTRICT, SqlBaseParser.REVOKE, SqlBaseParser.ROLLBACK, SqlBaseParser.ROW, SqlBaseParser.ROWS, SqlBaseParser.SCHEMA, SqlBaseParser.SCHEMAS, SqlBaseParser.SECOND, SqlBaseParser.SESSION, SqlBaseParser.SET, SqlBaseParser.SETS, SqlBaseParser.SHOW, SqlBaseParser.SMALLINT, SqlBaseParser.SOME, SqlBaseParser.START, SqlBaseParser.STATS, SqlBaseParser.SUBSTRING, SqlBaseParser.SYSTEM, SqlBaseParser.TABLES, SqlBaseParser.TABLESAMPLE, SqlBaseParser.TEXT, SqlBaseParser.TIME, SqlBaseParser.TIMESTAMP, SqlBaseParser.TINYINT, SqlBaseParser.TO, SqlBaseParser.TRY_CAST, SqlBaseParser.TYPE, SqlBaseParser.UNBOUNDED, SqlBaseParser.UNCOMMITTED, SqlBaseParser.USE, SqlBaseParser.VALIDATE, SqlBaseParser.VERBOSE, SqlBaseParser.VIEW, SqlBaseParser.WORK, SqlBaseParser.WRITE, SqlBaseParser.YEAR, SqlBaseParser.ZONE, SqlBaseParser.IDENTIFIER, SqlBaseParser.DIGIT_IDENTIFIER, SqlBaseParser.BACKQUOTED_IDENTIFIER]:
                    self.state = 334
                    self.columnAliases()
                    pass
                elif token in [SqlBaseParser.ASTERISK]:
                    self.state = 335
                    self.match(SqlBaseParser.ASTERISK)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 353
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.WITH:
                    self.state = 338
                    self.match(SqlBaseParser.WITH)
                    self.state = 351
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
                    if la_ == 1:
                        self.state = 340
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN:
                            self.state = 339
                            self.minRatioExpression()


                        self.state = 343
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN_SUPPORT:
                            self.state = 342
                            self.minSupportExpression()


                        pass

                    elif la_ == 2:
                        self.state = 346
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN_SUPPORT:
                            self.state = 345
                            self.minSupportExpression()


                        self.state = 349
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN:
                            self.state = 348
                            self.minRatioExpression()


                        pass




                self.state = 358
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.COMPARE:
                    self.state = 355
                    self.match(SqlBaseParser.COMPARE)
                    self.state = 356
                    self.match(SqlBaseParser.BY)
                    self.state = 357
                    self.ratioMetricExpression()


                self.state = 363
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.MAX:
                    self.state = 360
                    self.match(SqlBaseParser.MAX)
                    self.state = 361
                    self.match(SqlBaseParser.COMBO)
                    self.state = 362
                    localctx.maxCombo = self.match(SqlBaseParser.INTEGER_VALUE)


                self.state = 367
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
                if la_ == 1:
                    self.state = 365
                    self.match(SqlBaseParser.WHERE)
                    self.state = 366
                    localctx.where = self.booleanExpression(0)


                self.state = 379
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.ORDER:
                    self.state = 369
                    self.match(SqlBaseParser.ORDER)
                    self.state = 370
                    self.match(SqlBaseParser.BY)
                    self.state = 371
                    self.sortItem()
                    self.state = 376
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,56,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 372
                            self.match(SqlBaseParser.T__1)
                            self.state = 373
                            self.sortItem() 
                        self.state = 378
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,56,self._ctx)



                self.state = 383
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
                if la_ == 1:
                    self.state = 381
                    self.match(SqlBaseParser.LIMIT)
                    self.state = 382
                    localctx.limit = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==SqlBaseParser.ALL or _la==SqlBaseParser.INTEGER_VALUE):
                        localctx.limit = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 385
                self.match(SqlBaseParser.SELECT)
                self.state = 387
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
                if la_ == 1:
                    self.state = 386
                    self.setQuantifier()


                self.state = 389
                self.selectItem()
                self.state = 394
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SqlBaseParser.T__1:
                    self.state = 390
                    self.match(SqlBaseParser.T__1)
                    self.state = 391
                    self.selectItem()
                    self.state = 396
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 397
                self.match(SqlBaseParser.FROM)
                self.state = 398
                self.match(SqlBaseParser.DIFF)
                self.state = 399
                self.match(SqlBaseParser.T__0)
                self.state = 400
                self.splitQuery()
                self.state = 401
                self.match(SqlBaseParser.T__2)
                self.state = 402
                self.match(SqlBaseParser.ON)
                self.state = 405
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [SqlBaseParser.ADD, SqlBaseParser.ALL, SqlBaseParser.ANALYZE, SqlBaseParser.ANY, SqlBaseParser.ARRAY, SqlBaseParser.ASC, SqlBaseParser.AT, SqlBaseParser.BERNOULLI, SqlBaseParser.CALL, SqlBaseParser.CASCADE, SqlBaseParser.CATALOGS, SqlBaseParser.COALESCE, SqlBaseParser.COLUMN, SqlBaseParser.COLUMNS, SqlBaseParser.COMMENT, SqlBaseParser.COMMIT, SqlBaseParser.COMMITTED, SqlBaseParser.CURRENT, SqlBaseParser.DATA, SqlBaseParser.DATE, SqlBaseParser.DAY, SqlBaseParser.DESC, SqlBaseParser.DISTRIBUTED, SqlBaseParser.EXCLUDING, SqlBaseParser.EXPLAIN, SqlBaseParser.FILTER, SqlBaseParser.FIRST, SqlBaseParser.FOLLOWING, SqlBaseParser.FORMAT, SqlBaseParser.FUNCTIONS, SqlBaseParser.GRANT, SqlBaseParser.GRANTS, SqlBaseParser.GRAPHVIZ, SqlBaseParser.HOUR, SqlBaseParser.IF, SqlBaseParser.INCLUDING, SqlBaseParser.INPUT, SqlBaseParser.INTEGER, SqlBaseParser.INTERVAL, SqlBaseParser.ISOLATION, SqlBaseParser.LAST, SqlBaseParser.LATERAL, SqlBaseParser.LEVEL, SqlBaseParser.LIMIT, SqlBaseParser.LOGICAL, SqlBaseParser.MAP, SqlBaseParser.MINUTE, SqlBaseParser.MONTH, SqlBaseParser.NFC, SqlBaseParser.NFD, SqlBaseParser.NFKC, SqlBaseParser.NFKD, SqlBaseParser.NO, SqlBaseParser.NULLIF, SqlBaseParser.NULLS, SqlBaseParser.ONLY, SqlBaseParser.OPTION, SqlBaseParser.ORDINALITY, SqlBaseParser.OUTPUT, SqlBaseParser.OVER, SqlBaseParser.PARTITION, SqlBaseParser.PARTITIONS, SqlBaseParser.POSITION, SqlBaseParser.PRECEDING, SqlBaseParser.PRIVILEGES, SqlBaseParser.PROPERTIES, SqlBaseParser.PUBLIC, SqlBaseParser.RANGE, SqlBaseParser.READ, SqlBaseParser.RENAME, SqlBaseParser.REPEATABLE, SqlBaseParser.REPLACE, SqlBaseParser.RESET, SqlBaseParser.RESTRICT, SqlBaseParser.REVOKE, SqlBaseParser.ROLLBACK, SqlBaseParser.ROW, SqlBaseParser.ROWS, SqlBaseParser.SCHEMA, SqlBaseParser.SCHEMAS, SqlBaseParser.SECOND, SqlBaseParser.SESSION, SqlBaseParser.SET, SqlBaseParser.SETS, SqlBaseParser.SHOW, SqlBaseParser.SMALLINT, SqlBaseParser.SOME, SqlBaseParser.START, SqlBaseParser.STATS, SqlBaseParser.SUBSTRING, SqlBaseParser.SYSTEM, SqlBaseParser.TABLES, SqlBaseParser.TABLESAMPLE, SqlBaseParser.TEXT, SqlBaseParser.TIME, SqlBaseParser.TIMESTAMP, SqlBaseParser.TINYINT, SqlBaseParser.TO, SqlBaseParser.TRY_CAST, SqlBaseParser.TYPE, SqlBaseParser.UNBOUNDED, SqlBaseParser.UNCOMMITTED, SqlBaseParser.USE, SqlBaseParser.VALIDATE, SqlBaseParser.VERBOSE, SqlBaseParser.VIEW, SqlBaseParser.WORK, SqlBaseParser.WRITE, SqlBaseParser.YEAR, SqlBaseParser.ZONE, SqlBaseParser.IDENTIFIER, SqlBaseParser.DIGIT_IDENTIFIER, SqlBaseParser.BACKQUOTED_IDENTIFIER]:
                    self.state = 403
                    self.columnAliases()
                    pass
                elif token in [SqlBaseParser.ASTERISK]:
                    self.state = 404
                    self.match(SqlBaseParser.ASTERISK)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 422
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.WITH:
                    self.state = 407
                    self.match(SqlBaseParser.WITH)
                    self.state = 420
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
                    if la_ == 1:
                        self.state = 409
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN:
                            self.state = 408
                            self.minRatioExpression()


                        self.state = 412
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN_SUPPORT:
                            self.state = 411
                            self.minSupportExpression()


                        pass

                    elif la_ == 2:
                        self.state = 415
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN_SUPPORT:
                            self.state = 414
                            self.minSupportExpression()


                        self.state = 418
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN:
                            self.state = 417
                            self.minRatioExpression()


                        pass




                self.state = 427
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.COMPARE:
                    self.state = 424
                    self.match(SqlBaseParser.COMPARE)
                    self.state = 425
                    self.match(SqlBaseParser.BY)
                    self.state = 426
                    self.ratioMetricExpression()


                self.state = 432
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.MAX:
                    self.state = 429
                    self.match(SqlBaseParser.MAX)
                    self.state = 430
                    self.match(SqlBaseParser.COMBO)
                    self.state = 431
                    localctx.maxCombo = self.match(SqlBaseParser.INTEGER_VALUE)


                self.state = 436
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
                if la_ == 1:
                    self.state = 434
                    self.match(SqlBaseParser.WHERE)
                    self.state = 435
                    localctx.where = self.booleanExpression(0)


                self.state = 448
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.ORDER:
                    self.state = 438
                    self.match(SqlBaseParser.ORDER)
                    self.state = 439
                    self.match(SqlBaseParser.BY)
                    self.state = 440
                    self.sortItem()
                    self.state = 445
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,71,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 441
                            self.match(SqlBaseParser.T__1)
                            self.state = 442
                            self.sortItem() 
                        self.state = 447
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,71,self._ctx)



                self.state = 452
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
                if la_ == 1:
                    self.state = 450
                    self.match(SqlBaseParser.LIMIT)
                    self.state = 451
                    localctx.limit = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==SqlBaseParser.ALL or _la==SqlBaseParser.INTEGER_VALUE):
                        localctx.limit = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 455
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.INTO:
                    self.state = 454
                    self.exportClause()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 457
                self.match(SqlBaseParser.SELECT)
                self.state = 459
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
                if la_ == 1:
                    self.state = 458
                    self.setQuantifier()


                self.state = 461
                self.selectItem()
                self.state = 466
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SqlBaseParser.T__1:
                    self.state = 462
                    self.match(SqlBaseParser.T__1)
                    self.state = 463
                    self.selectItem()
                    self.state = 468
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 470
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.INTO:
                    self.state = 469
                    self.exportClause()


                self.state = 472
                self.match(SqlBaseParser.FROM)
                self.state = 473
                self.match(SqlBaseParser.DIFF)
                self.state = 474
                self.match(SqlBaseParser.T__0)
                self.state = 475
                self.splitQuery()
                self.state = 476
                self.match(SqlBaseParser.T__2)
                self.state = 477
                self.match(SqlBaseParser.ON)
                self.state = 480
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [SqlBaseParser.ADD, SqlBaseParser.ALL, SqlBaseParser.ANALYZE, SqlBaseParser.ANY, SqlBaseParser.ARRAY, SqlBaseParser.ASC, SqlBaseParser.AT, SqlBaseParser.BERNOULLI, SqlBaseParser.CALL, SqlBaseParser.CASCADE, SqlBaseParser.CATALOGS, SqlBaseParser.COALESCE, SqlBaseParser.COLUMN, SqlBaseParser.COLUMNS, SqlBaseParser.COMMENT, SqlBaseParser.COMMIT, SqlBaseParser.COMMITTED, SqlBaseParser.CURRENT, SqlBaseParser.DATA, SqlBaseParser.DATE, SqlBaseParser.DAY, SqlBaseParser.DESC, SqlBaseParser.DISTRIBUTED, SqlBaseParser.EXCLUDING, SqlBaseParser.EXPLAIN, SqlBaseParser.FILTER, SqlBaseParser.FIRST, SqlBaseParser.FOLLOWING, SqlBaseParser.FORMAT, SqlBaseParser.FUNCTIONS, SqlBaseParser.GRANT, SqlBaseParser.GRANTS, SqlBaseParser.GRAPHVIZ, SqlBaseParser.HOUR, SqlBaseParser.IF, SqlBaseParser.INCLUDING, SqlBaseParser.INPUT, SqlBaseParser.INTEGER, SqlBaseParser.INTERVAL, SqlBaseParser.ISOLATION, SqlBaseParser.LAST, SqlBaseParser.LATERAL, SqlBaseParser.LEVEL, SqlBaseParser.LIMIT, SqlBaseParser.LOGICAL, SqlBaseParser.MAP, SqlBaseParser.MINUTE, SqlBaseParser.MONTH, SqlBaseParser.NFC, SqlBaseParser.NFD, SqlBaseParser.NFKC, SqlBaseParser.NFKD, SqlBaseParser.NO, SqlBaseParser.NULLIF, SqlBaseParser.NULLS, SqlBaseParser.ONLY, SqlBaseParser.OPTION, SqlBaseParser.ORDINALITY, SqlBaseParser.OUTPUT, SqlBaseParser.OVER, SqlBaseParser.PARTITION, SqlBaseParser.PARTITIONS, SqlBaseParser.POSITION, SqlBaseParser.PRECEDING, SqlBaseParser.PRIVILEGES, SqlBaseParser.PROPERTIES, SqlBaseParser.PUBLIC, SqlBaseParser.RANGE, SqlBaseParser.READ, SqlBaseParser.RENAME, SqlBaseParser.REPEATABLE, SqlBaseParser.REPLACE, SqlBaseParser.RESET, SqlBaseParser.RESTRICT, SqlBaseParser.REVOKE, SqlBaseParser.ROLLBACK, SqlBaseParser.ROW, SqlBaseParser.ROWS, SqlBaseParser.SCHEMA, SqlBaseParser.SCHEMAS, SqlBaseParser.SECOND, SqlBaseParser.SESSION, SqlBaseParser.SET, SqlBaseParser.SETS, SqlBaseParser.SHOW, SqlBaseParser.SMALLINT, SqlBaseParser.SOME, SqlBaseParser.START, SqlBaseParser.STATS, SqlBaseParser.SUBSTRING, SqlBaseParser.SYSTEM, SqlBaseParser.TABLES, SqlBaseParser.TABLESAMPLE, SqlBaseParser.TEXT, SqlBaseParser.TIME, SqlBaseParser.TIMESTAMP, SqlBaseParser.TINYINT, SqlBaseParser.TO, SqlBaseParser.TRY_CAST, SqlBaseParser.TYPE, SqlBaseParser.UNBOUNDED, SqlBaseParser.UNCOMMITTED, SqlBaseParser.USE, SqlBaseParser.VALIDATE, SqlBaseParser.VERBOSE, SqlBaseParser.VIEW, SqlBaseParser.WORK, SqlBaseParser.WRITE, SqlBaseParser.YEAR, SqlBaseParser.ZONE, SqlBaseParser.IDENTIFIER, SqlBaseParser.DIGIT_IDENTIFIER, SqlBaseParser.BACKQUOTED_IDENTIFIER]:
                    self.state = 478
                    self.columnAliases()
                    pass
                elif token in [SqlBaseParser.ASTERISK]:
                    self.state = 479
                    self.match(SqlBaseParser.ASTERISK)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 497
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.WITH:
                    self.state = 482
                    self.match(SqlBaseParser.WITH)
                    self.state = 495
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
                    if la_ == 1:
                        self.state = 484
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN:
                            self.state = 483
                            self.minRatioExpression()


                        self.state = 487
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN_SUPPORT:
                            self.state = 486
                            self.minSupportExpression()


                        pass

                    elif la_ == 2:
                        self.state = 490
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN_SUPPORT:
                            self.state = 489
                            self.minSupportExpression()


                        self.state = 493
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlBaseParser.MIN:
                            self.state = 492
                            self.minRatioExpression()


                        pass




                self.state = 502
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.COMPARE:
                    self.state = 499
                    self.match(SqlBaseParser.COMPARE)
                    self.state = 500
                    self.match(SqlBaseParser.BY)
                    self.state = 501
                    self.ratioMetricExpression()


                self.state = 507
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.MAX:
                    self.state = 504
                    self.match(SqlBaseParser.MAX)
                    self.state = 505
                    self.match(SqlBaseParser.COMBO)
                    self.state = 506
                    localctx.maxCombo = self.match(SqlBaseParser.INTEGER_VALUE)


                self.state = 511
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,87,self._ctx)
                if la_ == 1:
                    self.state = 509
                    self.match(SqlBaseParser.WHERE)
                    self.state = 510
                    localctx.where = self.booleanExpression(0)


                self.state = 523
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.ORDER:
                    self.state = 513
                    self.match(SqlBaseParser.ORDER)
                    self.state = 514
                    self.match(SqlBaseParser.BY)
                    self.state = 515
                    self.sortItem()
                    self.state = 520
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,88,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 516
                            self.match(SqlBaseParser.T__1)
                            self.state = 517
                            self.sortItem() 
                        self.state = 522
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,88,self._ctx)



                self.state = 527
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
                if la_ == 1:
                    self.state = 525
                    self.match(SqlBaseParser.LIMIT)
                    self.state = 526
                    localctx.limit = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==SqlBaseParser.ALL or _la==SqlBaseParser.INTEGER_VALUE):
                        localctx.limit = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SplitQueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.where = None # BooleanExpressionContext

        def SPLIT(self):
            return self.getToken(SqlBaseParser.SPLIT, 0)

        def relation(self):
            return self.getTypedRuleContext(SqlBaseParser.RelationContext,0)


        def WHERE(self):
            return self.getToken(SqlBaseParser.WHERE, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,0)


        def queryTerm(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryTermContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_splitQuery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSplitQuery" ):
                listener.enterSplitQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSplitQuery" ):
                listener.exitSplitQuery(self)




    def splitQuery(self):

        localctx = SqlBaseParser.SplitQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_splitQuery)
        try:
            self.state = 541
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 531
                self.match(SqlBaseParser.SPLIT)
                self.state = 532
                self.relation(0)
                self.state = 533
                self.match(SqlBaseParser.WHERE)
                self.state = 534
                localctx.where = self.booleanExpression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 536
                self.match(SqlBaseParser.SPLIT)
                self.state = 537
                self.queryTerm()
                self.state = 538
                self.match(SqlBaseParser.WHERE)
                self.state = 539
                localctx.where = self.booleanExpression(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnDefinitionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)


        def type(self):
            return self.getTypedRuleContext(SqlBaseParser.TypeContext,0)


        def COMMENT(self):
            return self.getToken(SqlBaseParser.COMMENT, 0)

        def string(self):
            return self.getTypedRuleContext(SqlBaseParser.StringContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_columnDefinition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnDefinition" ):
                listener.enterColumnDefinition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnDefinition" ):
                listener.exitColumnDefinition(self)




    def columnDefinition(self):

        localctx = SqlBaseParser.ColumnDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_columnDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 543
            self.identifier()
            self.state = 544
            self.type(0)
            self.state = 547
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlBaseParser.COMMENT:
                self.state = 545
                self.match(SqlBaseParser.COMMENT)
                self.state = 546
                self.string()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SortItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ordering = None # Token
            self.nullOrdering = None # Token

        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)


        def NULLS(self):
            return self.getToken(SqlBaseParser.NULLS, 0)

        def ASC(self):
            return self.getToken(SqlBaseParser.ASC, 0)

        def DESC(self):
            return self.getToken(SqlBaseParser.DESC, 0)

        def FIRST(self):
            return self.getToken(SqlBaseParser.FIRST, 0)

        def LAST(self):
            return self.getToken(SqlBaseParser.LAST, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_sortItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSortItem" ):
                listener.enterSortItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSortItem" ):
                listener.exitSortItem(self)




    def sortItem(self):

        localctx = SqlBaseParser.SortItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_sortItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 549
            self.expression()
            self.state = 551
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                self.state = 550
                localctx.ordering = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==SqlBaseParser.ASC or _la==SqlBaseParser.DESC):
                    localctx.ordering = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 555
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
            if la_ == 1:
                self.state = 553
                self.match(SqlBaseParser.NULLS)
                self.state = 554
                localctx.nullOrdering = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==SqlBaseParser.FIRST or _la==SqlBaseParser.LAST):
                    localctx.nullOrdering = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinRatioExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.minRatio = None # Token

        def MIN(self):
            return self.getToken(SqlBaseParser.MIN, 0)

        def RATIO(self):
            return self.getToken(SqlBaseParser.RATIO, 0)

        def DECIMAL_VALUE(self):
            return self.getToken(SqlBaseParser.DECIMAL_VALUE, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_minRatioExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinRatioExpression" ):
                listener.enterMinRatioExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinRatioExpression" ):
                listener.exitMinRatioExpression(self)




    def minRatioExpression(self):

        localctx = SqlBaseParser.MinRatioExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_minRatioExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 557
            self.match(SqlBaseParser.MIN)
            self.state = 558
            self.match(SqlBaseParser.RATIO)
            self.state = 559
            localctx.minRatio = self.match(SqlBaseParser.DECIMAL_VALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinSupportExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.minSupport = None # Token

        def MIN_SUPPORT(self):
            return self.getToken(SqlBaseParser.MIN_SUPPORT, 0)

        def DECIMAL_VALUE(self):
            return self.getToken(SqlBaseParser.DECIMAL_VALUE, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_minSupportExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinSupportExpression" ):
                listener.enterMinSupportExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinSupportExpression" ):
                listener.exitMinSupportExpression(self)




    def minSupportExpression(self):

        localctx = SqlBaseParser.MinSupportExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_minSupportExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 561
            self.match(SqlBaseParser.MIN_SUPPORT)
            self.state = 562
            localctx.minSupport = self.match(SqlBaseParser.DECIMAL_VALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RatioMetricExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)


        def aggregateExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.AggregateExpressionContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_ratioMetricExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRatioMetricExpression" ):
                listener.enterRatioMetricExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRatioMetricExpression" ):
                listener.exitRatioMetricExpression(self)




    def ratioMetricExpression(self):

        localctx = SqlBaseParser.RatioMetricExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_ratioMetricExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 564
            self.identifier()
            self.state = 565
            self.match(SqlBaseParser.T__0)
            self.state = 566
            self.aggregateExpression()
            self.state = 567
            self.match(SqlBaseParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregateExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aggregate(self):
            return self.getTypedRuleContext(SqlBaseParser.AggregateContext,0)


        def ASTERISK(self):
            return self.getToken(SqlBaseParser.ASTERISK, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_aggregateExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregateExpression" ):
                listener.enterAggregateExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregateExpression" ):
                listener.exitAggregateExpression(self)




    def aggregateExpression(self):

        localctx = SqlBaseParser.AggregateExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_aggregateExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 569
            self.aggregate()
            self.state = 570
            self.match(SqlBaseParser.T__0)
            self.state = 571
            self.match(SqlBaseParser.ASTERISK)
            self.state = 572
            self.match(SqlBaseParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COUNT(self):
            return self.getToken(SqlBaseParser.COUNT, 0)

        def MIN(self):
            return self.getToken(SqlBaseParser.MIN, 0)

        def MAX(self):
            return self.getToken(SqlBaseParser.MAX, 0)

        def SUM(self):
            return self.getToken(SqlBaseParser.SUM, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_aggregate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregate" ):
                listener.enterAggregate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregate" ):
                listener.exitAggregate(self)




    def aggregate(self):

        localctx = SqlBaseParser.AggregateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_aggregate)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 574
            _la = self._input.LA(1)
            if not(_la==SqlBaseParser.COUNT or _la==SqlBaseParser.MAX or _la==SqlBaseParser.MIN or _la==SqlBaseParser.SUM):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetQuantifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISTINCT(self):
            return self.getToken(SqlBaseParser.DISTINCT, 0)

        def ALL(self):
            return self.getToken(SqlBaseParser.ALL, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_setQuantifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetQuantifier" ):
                listener.enterSetQuantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetQuantifier" ):
                listener.exitSetQuantifier(self)




    def setQuantifier(self):

        localctx = SqlBaseParser.SetQuantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_setQuantifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 576
            _la = self._input.LA(1)
            if not(_la==SqlBaseParser.ALL or _la==SqlBaseParser.DISTINCT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_selectItem

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SelectAllContext(SelectItemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.SelectItemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def qualifiedName(self):
            return self.getTypedRuleContext(SqlBaseParser.QualifiedNameContext,0)

        def ASTERISK(self):
            return self.getToken(SqlBaseParser.ASTERISK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectAll" ):
                listener.enterSelectAll(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectAll" ):
                listener.exitSelectAll(self)


    class SelectSingleContext(SelectItemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.SelectItemContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)

        def AS(self):
            return self.getToken(SqlBaseParser.AS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectSingle" ):
                listener.enterSelectSingle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectSingle" ):
                listener.exitSelectSingle(self)



    def selectItem(self):

        localctx = SqlBaseParser.SelectItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_selectItem)
        self._la = 0 # Token type
        try:
            self.state = 590
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.SelectSingleContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 578
                self.expression()
                self.state = 583
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
                if la_ == 1:
                    self.state = 580
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==SqlBaseParser.AS:
                        self.state = 579
                        self.match(SqlBaseParser.AS)


                    self.state = 582
                    self.identifier()


                pass

            elif la_ == 2:
                localctx = SqlBaseParser.SelectAllContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 585
                self.qualifiedName()
                self.state = 586
                self.match(SqlBaseParser.T__3)
                self.state = 587
                self.match(SqlBaseParser.ASTERISK)
                pass

            elif la_ == 3:
                localctx = SqlBaseParser.SelectAllContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 589
                self.match(SqlBaseParser.ASTERISK)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExportClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.filename = None # Token
            self.fieldsFormat = None # Token

        def INTO(self):
            return self.getToken(SqlBaseParser.INTO, 0)

        def OUTFILE(self):
            return self.getToken(SqlBaseParser.OUTFILE, 0)

        def STRING(self):
            return self.getToken(SqlBaseParser.STRING, 0)

        def delimiterClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.DelimiterClauseContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.DelimiterClauseContext,i)


        def LINES(self):
            return self.getToken(SqlBaseParser.LINES, 0)

        def FIELDS(self):
            return self.getToken(SqlBaseParser.FIELDS, 0)

        def COLUMNS(self):
            return self.getToken(SqlBaseParser.COLUMNS, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_exportClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExportClause" ):
                listener.enterExportClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExportClause" ):
                listener.exitExportClause(self)




    def exportClause(self):

        localctx = SqlBaseParser.ExportClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_exportClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 592
            self.match(SqlBaseParser.INTO)
            self.state = 593
            self.match(SqlBaseParser.OUTFILE)
            self.state = 594
            localctx.filename = self.match(SqlBaseParser.STRING)
            self.state = 597
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 595
                localctx.fieldsFormat = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==SqlBaseParser.COLUMNS or _la==SqlBaseParser.FIELDS):
                    localctx.fieldsFormat = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 596
                self.delimiterClause()


            self.state = 601
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlBaseParser.LINES:
                self.state = 599
                self.match(SqlBaseParser.LINES)
                self.state = 600
                self.delimiterClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DelimiterClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.delimiter = None # Token

        def TERMINATED(self):
            return self.getToken(SqlBaseParser.TERMINATED, 0)

        def BY(self):
            return self.getToken(SqlBaseParser.BY, 0)

        def STRING(self):
            return self.getToken(SqlBaseParser.STRING, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_delimiterClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelimiterClause" ):
                listener.enterDelimiterClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelimiterClause" ):
                listener.exitDelimiterClause(self)




    def delimiterClause(self):

        localctx = SqlBaseParser.DelimiterClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_delimiterClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 603
            self.match(SqlBaseParser.TERMINATED)
            self.state = 604
            self.match(SqlBaseParser.BY)
            self.state = 605
            localctx.delimiter = self.match(SqlBaseParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EscapeClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.escaping = None # Token

        def ESCAPED(self):
            return self.getToken(SqlBaseParser.ESCAPED, 0)

        def BY(self):
            return self.getToken(SqlBaseParser.BY, 0)

        def STRING(self):
            return self.getToken(SqlBaseParser.STRING, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_escapeClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEscapeClause" ):
                listener.enterEscapeClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEscapeClause" ):
                listener.exitEscapeClause(self)




    def escapeClause(self):

        localctx = SqlBaseParser.EscapeClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_escapeClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 607
            self.match(SqlBaseParser.ESCAPED)
            self.state = 608
            self.match(SqlBaseParser.BY)
            self.state = 609
            localctx.escaping = self.match(SqlBaseParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_relation

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class RelationDefaultContext(RelationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.RelationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def aliasedRelation(self):
            return self.getTypedRuleContext(SqlBaseParser.AliasedRelationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationDefault" ):
                listener.enterRelationDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationDefault" ):
                listener.exitRelationDefault(self)


    class JoinRelationContext(RelationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.RelationContext
            super().__init__(parser)
            self.left = None # RelationContext
            self.right = None # AliasedRelationContext
            self.rightRelation = None # RelationContext
            self.copyFrom(ctx)

        def relation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.RelationContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.RelationContext,i)

        def CROSS(self):
            return self.getToken(SqlBaseParser.CROSS, 0)
        def JOIN(self):
            return self.getToken(SqlBaseParser.JOIN, 0)
        def joinType(self):
            return self.getTypedRuleContext(SqlBaseParser.JoinTypeContext,0)

        def joinCriteria(self):
            return self.getTypedRuleContext(SqlBaseParser.JoinCriteriaContext,0)

        def NATURAL(self):
            return self.getToken(SqlBaseParser.NATURAL, 0)
        def aliasedRelation(self):
            return self.getTypedRuleContext(SqlBaseParser.AliasedRelationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinRelation" ):
                listener.enterJoinRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinRelation" ):
                listener.exitJoinRelation(self)



    def relation(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlBaseParser.RelationContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 42
        self.enterRecursionRule(localctx, 42, self.RULE_relation, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = SqlBaseParser.RelationDefaultContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 612
            self.aliasedRelation()
            self._ctx.stop = self._input.LT(-1)
            self.state = 632
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,102,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = SqlBaseParser.JoinRelationContext(self, SqlBaseParser.RelationContext(self, _parentctx, _parentState))
                    localctx.left = _prevctx
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_relation)
                    self.state = 614
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 628
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [SqlBaseParser.CROSS]:
                        self.state = 615
                        self.match(SqlBaseParser.CROSS)
                        self.state = 616
                        self.match(SqlBaseParser.JOIN)
                        self.state = 617
                        localctx.right = self.aliasedRelation()
                        pass
                    elif token in [SqlBaseParser.FULL, SqlBaseParser.INNER, SqlBaseParser.JOIN, SqlBaseParser.LEFT, SqlBaseParser.RIGHT]:
                        self.state = 618
                        self.joinType()
                        self.state = 619
                        self.match(SqlBaseParser.JOIN)
                        self.state = 620
                        localctx.rightRelation = self.relation(0)
                        self.state = 621
                        self.joinCriteria()
                        pass
                    elif token in [SqlBaseParser.NATURAL]:
                        self.state = 623
                        self.match(SqlBaseParser.NATURAL)
                        self.state = 624
                        self.joinType()
                        self.state = 625
                        self.match(SqlBaseParser.JOIN)
                        self.state = 626
                        localctx.right = self.aliasedRelation()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 634
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,102,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class JoinTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INNER(self):
            return self.getToken(SqlBaseParser.INNER, 0)

        def LEFT(self):
            return self.getToken(SqlBaseParser.LEFT, 0)

        def OUTER(self):
            return self.getToken(SqlBaseParser.OUTER, 0)

        def RIGHT(self):
            return self.getToken(SqlBaseParser.RIGHT, 0)

        def FULL(self):
            return self.getToken(SqlBaseParser.FULL, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_joinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinType" ):
                listener.enterJoinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinType" ):
                listener.exitJoinType(self)




    def joinType(self):

        localctx = SqlBaseParser.JoinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_joinType)
        self._la = 0 # Token type
        try:
            self.state = 650
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlBaseParser.INNER, SqlBaseParser.JOIN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 636
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.INNER:
                    self.state = 635
                    self.match(SqlBaseParser.INNER)


                pass
            elif token in [SqlBaseParser.LEFT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 638
                self.match(SqlBaseParser.LEFT)
                self.state = 640
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.OUTER:
                    self.state = 639
                    self.match(SqlBaseParser.OUTER)


                pass
            elif token in [SqlBaseParser.RIGHT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 642
                self.match(SqlBaseParser.RIGHT)
                self.state = 644
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.OUTER:
                    self.state = 643
                    self.match(SqlBaseParser.OUTER)


                pass
            elif token in [SqlBaseParser.FULL]:
                self.enterOuterAlt(localctx, 4)
                self.state = 646
                self.match(SqlBaseParser.FULL)
                self.state = 648
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.OUTER:
                    self.state = 647
                    self.match(SqlBaseParser.OUTER)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinCriteriaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON(self):
            return self.getToken(SqlBaseParser.ON, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,0)


        def USING(self):
            return self.getToken(SqlBaseParser.USING, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_joinCriteria

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinCriteria" ):
                listener.enterJoinCriteria(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinCriteria" ):
                listener.exitJoinCriteria(self)




    def joinCriteria(self):

        localctx = SqlBaseParser.JoinCriteriaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_joinCriteria)
        self._la = 0 # Token type
        try:
            self.state = 666
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlBaseParser.ON]:
                self.enterOuterAlt(localctx, 1)
                self.state = 652
                self.match(SqlBaseParser.ON)
                self.state = 653
                self.booleanExpression(0)
                pass
            elif token in [SqlBaseParser.USING]:
                self.enterOuterAlt(localctx, 2)
                self.state = 654
                self.match(SqlBaseParser.USING)
                self.state = 655
                self.match(SqlBaseParser.T__0)
                self.state = 656
                self.identifier()
                self.state = 661
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SqlBaseParser.T__1:
                    self.state = 657
                    self.match(SqlBaseParser.T__1)
                    self.state = 658
                    self.identifier()
                    self.state = 663
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 664
                self.match(SqlBaseParser.T__2)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasedRelationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relationPrimary(self):
            return self.getTypedRuleContext(SqlBaseParser.RelationPrimaryContext,0)


        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)


        def AS(self):
            return self.getToken(SqlBaseParser.AS, 0)

        def columnAliases(self):
            return self.getTypedRuleContext(SqlBaseParser.ColumnAliasesContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_aliasedRelation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAliasedRelation" ):
                listener.enterAliasedRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAliasedRelation" ):
                listener.exitAliasedRelation(self)




    def aliasedRelation(self):

        localctx = SqlBaseParser.AliasedRelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_aliasedRelation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 668
            self.relationPrimary()
            self.state = 679
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,112,self._ctx)
            if la_ == 1:
                self.state = 670
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.AS:
                    self.state = 669
                    self.match(SqlBaseParser.AS)


                self.state = 672
                self.identifier()
                self.state = 677
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,111,self._ctx)
                if la_ == 1:
                    self.state = 673
                    self.match(SqlBaseParser.T__0)
                    self.state = 674
                    self.columnAliases()
                    self.state = 675
                    self.match(SqlBaseParser.T__2)




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnAliasesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_columnAliases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnAliases" ):
                listener.enterColumnAliases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnAliases" ):
                listener.exitColumnAliases(self)




    def columnAliases(self):

        localctx = SqlBaseParser.ColumnAliasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_columnAliases)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 681
            self.identifier()
            self.state = 686
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,113,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 682
                    self.match(SqlBaseParser.T__1)
                    self.state = 683
                    self.identifier() 
                self.state = 688
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,113,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationPrimaryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_relationPrimary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SubqueryRelationContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.RelationPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubqueryRelation" ):
                listener.enterSubqueryRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubqueryRelation" ):
                listener.exitSubqueryRelation(self)


    class ParenthesizedRelationContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.RelationPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def relation(self):
            return self.getTypedRuleContext(SqlBaseParser.RelationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedRelation" ):
                listener.enterParenthesizedRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedRelation" ):
                listener.exitParenthesizedRelation(self)


    class TableNameContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.RelationPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def qualifiedName(self):
            return self.getTypedRuleContext(SqlBaseParser.QualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableName" ):
                listener.enterTableName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableName" ):
                listener.exitTableName(self)



    def relationPrimary(self):

        localctx = SqlBaseParser.RelationPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_relationPrimary)
        try:
            self.state = 698
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,114,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.TableNameContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 689
                self.qualifiedName()
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.SubqueryRelationContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 690
                self.match(SqlBaseParser.T__0)
                self.state = 691
                self.query()
                self.state = 692
                self.match(SqlBaseParser.T__2)
                pass

            elif la_ == 3:
                localctx = SqlBaseParser.ParenthesizedRelationContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 694
                self.match(SqlBaseParser.T__0)
                self.state = 695
                self.relation(0)
                self.state = 696
                self.match(SqlBaseParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)




    def expression(self):

        localctx = SqlBaseParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 700
            self.booleanExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_booleanExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class LogicalNotContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(SqlBaseParser.NOT, 0)
        def booleanExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalNot" ):
                listener.enterLogicalNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalNot" ):
                listener.exitLogicalNot(self)


    class BooleanDefaultContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def predicated(self):
            return self.getTypedRuleContext(SqlBaseParser.PredicatedContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanDefault" ):
                listener.enterBooleanDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanDefault" ):
                listener.exitBooleanDefault(self)


    class LogicalBinaryContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.BooleanExpressionContext
            super().__init__(parser)
            self.left = None # BooleanExpressionContext
            self.operator = None # Token
            self.right = None # BooleanExpressionContext
            self.copyFrom(ctx)

        def booleanExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.BooleanExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,i)

        def AND(self):
            return self.getToken(SqlBaseParser.AND, 0)
        def OR(self):
            return self.getToken(SqlBaseParser.OR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalBinary" ):
                listener.enterLogicalBinary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalBinary" ):
                listener.exitLogicalBinary(self)



    def booleanExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlBaseParser.BooleanExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 56
        self.enterRecursionRule(localctx, 56, self.RULE_booleanExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 706
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlBaseParser.T__0, SqlBaseParser.ADD, SqlBaseParser.ALL, SqlBaseParser.ANALYZE, SqlBaseParser.ANY, SqlBaseParser.ARRAY, SqlBaseParser.ASC, SqlBaseParser.AT, SqlBaseParser.BERNOULLI, SqlBaseParser.CALL, SqlBaseParser.CASCADE, SqlBaseParser.CATALOGS, SqlBaseParser.COALESCE, SqlBaseParser.COLUMN, SqlBaseParser.COLUMNS, SqlBaseParser.COMMENT, SqlBaseParser.COMMIT, SqlBaseParser.COMMITTED, SqlBaseParser.CURRENT, SqlBaseParser.DATA, SqlBaseParser.DATE, SqlBaseParser.DAY, SqlBaseParser.DESC, SqlBaseParser.DISTRIBUTED, SqlBaseParser.EXCLUDING, SqlBaseParser.EXISTS, SqlBaseParser.EXPLAIN, SqlBaseParser.FALSE, SqlBaseParser.FILTER, SqlBaseParser.FIRST, SqlBaseParser.FOLLOWING, SqlBaseParser.FORMAT, SqlBaseParser.FUNCTIONS, SqlBaseParser.GRANT, SqlBaseParser.GRANTS, SqlBaseParser.GRAPHVIZ, SqlBaseParser.HOUR, SqlBaseParser.IF, SqlBaseParser.INCLUDING, SqlBaseParser.INPUT, SqlBaseParser.INTEGER, SqlBaseParser.INTERVAL, SqlBaseParser.ISOLATION, SqlBaseParser.LAST, SqlBaseParser.LATERAL, SqlBaseParser.LEVEL, SqlBaseParser.LIMIT, SqlBaseParser.LOGICAL, SqlBaseParser.MAP, SqlBaseParser.MINUTE, SqlBaseParser.MONTH, SqlBaseParser.NFC, SqlBaseParser.NFD, SqlBaseParser.NFKC, SqlBaseParser.NFKD, SqlBaseParser.NO, SqlBaseParser.NULL, SqlBaseParser.NULLIF, SqlBaseParser.NULLS, SqlBaseParser.ONLY, SqlBaseParser.OPTION, SqlBaseParser.ORDINALITY, SqlBaseParser.OUTPUT, SqlBaseParser.OVER, SqlBaseParser.PARTITION, SqlBaseParser.PARTITIONS, SqlBaseParser.POSITION, SqlBaseParser.PRECEDING, SqlBaseParser.PRIVILEGES, SqlBaseParser.PROPERTIES, SqlBaseParser.PUBLIC, SqlBaseParser.RANGE, SqlBaseParser.READ, SqlBaseParser.RENAME, SqlBaseParser.REPEATABLE, SqlBaseParser.REPLACE, SqlBaseParser.RESET, SqlBaseParser.RESTRICT, SqlBaseParser.REVOKE, SqlBaseParser.ROLLBACK, SqlBaseParser.ROW, SqlBaseParser.ROWS, SqlBaseParser.SCHEMA, SqlBaseParser.SCHEMAS, SqlBaseParser.SECOND, SqlBaseParser.SESSION, SqlBaseParser.SET, SqlBaseParser.SETS, SqlBaseParser.SHOW, SqlBaseParser.SMALLINT, SqlBaseParser.SOME, SqlBaseParser.START, SqlBaseParser.STATS, SqlBaseParser.SUBSTRING, SqlBaseParser.SYSTEM, SqlBaseParser.TABLES, SqlBaseParser.TABLESAMPLE, SqlBaseParser.TEXT, SqlBaseParser.TIME, SqlBaseParser.TIMESTAMP, SqlBaseParser.TINYINT, SqlBaseParser.TO, SqlBaseParser.TRUE, SqlBaseParser.TRY_CAST, SqlBaseParser.TYPE, SqlBaseParser.UNBOUNDED, SqlBaseParser.UNCOMMITTED, SqlBaseParser.USE, SqlBaseParser.VALIDATE, SqlBaseParser.VERBOSE, SqlBaseParser.VIEW, SqlBaseParser.WORK, SqlBaseParser.WRITE, SqlBaseParser.YEAR, SqlBaseParser.ZONE, SqlBaseParser.PLUS, SqlBaseParser.MINUS, SqlBaseParser.STRING, SqlBaseParser.UNICODE_STRING, SqlBaseParser.BINARY_LITERAL, SqlBaseParser.INTEGER_VALUE, SqlBaseParser.DECIMAL_VALUE, SqlBaseParser.IDENTIFIER, SqlBaseParser.DIGIT_IDENTIFIER, SqlBaseParser.BACKQUOTED_IDENTIFIER, SqlBaseParser.DOUBLE_PRECISION]:
                localctx = SqlBaseParser.BooleanDefaultContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 703
                self.predicated()
                pass
            elif token in [SqlBaseParser.NOT]:
                localctx = SqlBaseParser.LogicalNotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 704
                self.match(SqlBaseParser.NOT)
                self.state = 705
                self.booleanExpression(3)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 716
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,117,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 714
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,116,self._ctx)
                    if la_ == 1:
                        localctx = SqlBaseParser.LogicalBinaryContext(self, SqlBaseParser.BooleanExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 708
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 709
                        localctx.operator = self.match(SqlBaseParser.AND)
                        self.state = 710
                        localctx.right = self.booleanExpression(3)
                        pass

                    elif la_ == 2:
                        localctx = SqlBaseParser.LogicalBinaryContext(self, SqlBaseParser.BooleanExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 711
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 712
                        localctx.operator = self.match(SqlBaseParser.OR)
                        self.state = 713
                        localctx.right = self.booleanExpression(2)
                        pass

             
                self.state = 718
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,117,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PredicatedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._valueExpression = None # ValueExpressionContext

        def valueExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,0)


        def predicate(self):
            return self.getTypedRuleContext(SqlBaseParser.PredicateContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_predicated

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicated" ):
                listener.enterPredicated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicated" ):
                listener.exitPredicated(self)




    def predicated(self):

        localctx = SqlBaseParser.PredicatedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_predicated)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 719
            localctx._valueExpression = self.valueExpression(0)
            self.state = 721
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
            if la_ == 1:
                self.state = 720
                self.predicate(localctx._valueExpression)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1, value:ParserRuleContext=None):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None
            self.value = value


        def getRuleIndex(self):
            return SqlBaseParser.RULE_predicate

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)
            self.value = ctx.value



    class ComparisonContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PredicateContext
            super().__init__(parser)
            self.right = None # ValueExpressionContext
            self.copyFrom(ctx)

        def comparisonOperator(self):
            return self.getTypedRuleContext(SqlBaseParser.ComparisonOperatorContext,0)

        def valueExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)


    class LikeContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PredicateContext
            super().__init__(parser)
            self.pattern = None # ValueExpressionContext
            self.escape = None # ValueExpressionContext
            self.copyFrom(ctx)

        def LIKE(self):
            return self.getToken(SqlBaseParser.LIKE, 0)
        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,i)

        def NOT(self):
            return self.getToken(SqlBaseParser.NOT, 0)
        def ESCAPE(self):
            return self.getToken(SqlBaseParser.ESCAPE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLike" ):
                listener.enterLike(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLike" ):
                listener.exitLike(self)


    class InSubqueryContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PredicateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IN(self):
            return self.getToken(SqlBaseParser.IN, 0)
        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)

        def NOT(self):
            return self.getToken(SqlBaseParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInSubquery" ):
                listener.enterInSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInSubquery" ):
                listener.exitInSubquery(self)


    class DistinctFromContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PredicateContext
            super().__init__(parser)
            self.right = None # ValueExpressionContext
            self.copyFrom(ctx)

        def IS(self):
            return self.getToken(SqlBaseParser.IS, 0)
        def DISTINCT(self):
            return self.getToken(SqlBaseParser.DISTINCT, 0)
        def FROM(self):
            return self.getToken(SqlBaseParser.FROM, 0)
        def valueExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,0)

        def NOT(self):
            return self.getToken(SqlBaseParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistinctFrom" ):
                listener.enterDistinctFrom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistinctFrom" ):
                listener.exitDistinctFrom(self)


    class InListContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PredicateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IN(self):
            return self.getToken(SqlBaseParser.IN, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,i)

        def NOT(self):
            return self.getToken(SqlBaseParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInList" ):
                listener.enterInList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInList" ):
                listener.exitInList(self)


    class NullPredicateContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PredicateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IS(self):
            return self.getToken(SqlBaseParser.IS, 0)
        def NULL(self):
            return self.getToken(SqlBaseParser.NULL, 0)
        def NOT(self):
            return self.getToken(SqlBaseParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNullPredicate" ):
                listener.enterNullPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNullPredicate" ):
                listener.exitNullPredicate(self)


    class BetweenContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PredicateContext
            super().__init__(parser)
            self.lower = None # ValueExpressionContext
            self.upper = None # ValueExpressionContext
            self.copyFrom(ctx)

        def BETWEEN(self):
            return self.getToken(SqlBaseParser.BETWEEN, 0)
        def AND(self):
            return self.getToken(SqlBaseParser.AND, 0)
        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,i)

        def NOT(self):
            return self.getToken(SqlBaseParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBetween" ):
                listener.enterBetween(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBetween" ):
                listener.exitBetween(self)


    class QuantifiedComparisonContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PredicateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def comparisonOperator(self):
            return self.getTypedRuleContext(SqlBaseParser.ComparisonOperatorContext,0)

        def comparisonQuantifier(self):
            return self.getTypedRuleContext(SqlBaseParser.ComparisonQuantifierContext,0)

        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantifiedComparison" ):
                listener.enterQuantifiedComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantifiedComparison" ):
                listener.exitQuantifiedComparison(self)



    def predicate(self, value:ParserRuleContext):

        localctx = SqlBaseParser.PredicateContext(self, self._ctx, self.state, value)
        self.enterRule(localctx, 60, self.RULE_predicate)
        self._la = 0 # Token type
        try:
            self.state = 784
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,127,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.ComparisonContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 723
                self.comparisonOperator()
                self.state = 724
                localctx.right = self.valueExpression(0)
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.QuantifiedComparisonContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 726
                self.comparisonOperator()
                self.state = 727
                self.comparisonQuantifier()
                self.state = 728
                self.match(SqlBaseParser.T__0)
                self.state = 729
                self.query()
                self.state = 730
                self.match(SqlBaseParser.T__2)
                pass

            elif la_ == 3:
                localctx = SqlBaseParser.BetweenContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 733
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.NOT:
                    self.state = 732
                    self.match(SqlBaseParser.NOT)


                self.state = 735
                self.match(SqlBaseParser.BETWEEN)
                self.state = 736
                localctx.lower = self.valueExpression(0)
                self.state = 737
                self.match(SqlBaseParser.AND)
                self.state = 738
                localctx.upper = self.valueExpression(0)
                pass

            elif la_ == 4:
                localctx = SqlBaseParser.InListContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 741
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.NOT:
                    self.state = 740
                    self.match(SqlBaseParser.NOT)


                self.state = 743
                self.match(SqlBaseParser.IN)
                self.state = 744
                self.match(SqlBaseParser.T__0)
                self.state = 745
                self.expression()
                self.state = 750
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SqlBaseParser.T__1:
                    self.state = 746
                    self.match(SqlBaseParser.T__1)
                    self.state = 747
                    self.expression()
                    self.state = 752
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 753
                self.match(SqlBaseParser.T__2)
                pass

            elif la_ == 5:
                localctx = SqlBaseParser.InSubqueryContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 756
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.NOT:
                    self.state = 755
                    self.match(SqlBaseParser.NOT)


                self.state = 758
                self.match(SqlBaseParser.IN)
                self.state = 759
                self.match(SqlBaseParser.T__0)
                self.state = 760
                self.query()
                self.state = 761
                self.match(SqlBaseParser.T__2)
                pass

            elif la_ == 6:
                localctx = SqlBaseParser.LikeContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 764
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.NOT:
                    self.state = 763
                    self.match(SqlBaseParser.NOT)


                self.state = 766
                self.match(SqlBaseParser.LIKE)
                self.state = 767
                localctx.pattern = self.valueExpression(0)
                self.state = 770
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,124,self._ctx)
                if la_ == 1:
                    self.state = 768
                    self.match(SqlBaseParser.ESCAPE)
                    self.state = 769
                    localctx.escape = self.valueExpression(0)


                pass

            elif la_ == 7:
                localctx = SqlBaseParser.NullPredicateContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 772
                self.match(SqlBaseParser.IS)
                self.state = 774
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.NOT:
                    self.state = 773
                    self.match(SqlBaseParser.NOT)


                self.state = 776
                self.match(SqlBaseParser.NULL)
                pass

            elif la_ == 8:
                localctx = SqlBaseParser.DistinctFromContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 777
                self.match(SqlBaseParser.IS)
                self.state = 779
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlBaseParser.NOT:
                    self.state = 778
                    self.match(SqlBaseParser.NOT)


                self.state = 781
                self.match(SqlBaseParser.DISTINCT)
                self.state = 782
                self.match(SqlBaseParser.FROM)
                self.state = 783
                localctx.right = self.valueExpression(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_valueExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class ValueExpressionDefaultContext(ValueExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ValueExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValueExpressionDefault" ):
                listener.enterValueExpressionDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValueExpressionDefault" ):
                listener.exitValueExpressionDefault(self)


    class ConcatenationContext(ValueExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ValueExpressionContext
            super().__init__(parser)
            self.left = None # ValueExpressionContext
            self.right = None # ValueExpressionContext
            self.copyFrom(ctx)

        def CONCAT(self):
            return self.getToken(SqlBaseParser.CONCAT, 0)
        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConcatenation" ):
                listener.enterConcatenation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConcatenation" ):
                listener.exitConcatenation(self)


    class ArithmeticBinaryContext(ValueExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ValueExpressionContext
            super().__init__(parser)
            self.left = None # ValueExpressionContext
            self.operator = None # Token
            self.right = None # ValueExpressionContext
            self.copyFrom(ctx)

        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,i)

        def ASTERISK(self):
            return self.getToken(SqlBaseParser.ASTERISK, 0)
        def SLASH(self):
            return self.getToken(SqlBaseParser.SLASH, 0)
        def PERCENT(self):
            return self.getToken(SqlBaseParser.PERCENT, 0)
        def PLUS(self):
            return self.getToken(SqlBaseParser.PLUS, 0)
        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmeticBinary" ):
                listener.enterArithmeticBinary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmeticBinary" ):
                listener.exitArithmeticBinary(self)


    class ArithmeticUnaryContext(ValueExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ValueExpressionContext
            super().__init__(parser)
            self.operator = None # Token
            self.copyFrom(ctx)

        def valueExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,0)

        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)
        def PLUS(self):
            return self.getToken(SqlBaseParser.PLUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmeticUnary" ):
                listener.enterArithmeticUnary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmeticUnary" ):
                listener.exitArithmeticUnary(self)



    def valueExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlBaseParser.ValueExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 62
        self.enterRecursionRule(localctx, 62, self.RULE_valueExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 790
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlBaseParser.T__0, SqlBaseParser.ADD, SqlBaseParser.ALL, SqlBaseParser.ANALYZE, SqlBaseParser.ANY, SqlBaseParser.ARRAY, SqlBaseParser.ASC, SqlBaseParser.AT, SqlBaseParser.BERNOULLI, SqlBaseParser.CALL, SqlBaseParser.CASCADE, SqlBaseParser.CATALOGS, SqlBaseParser.COALESCE, SqlBaseParser.COLUMN, SqlBaseParser.COLUMNS, SqlBaseParser.COMMENT, SqlBaseParser.COMMIT, SqlBaseParser.COMMITTED, SqlBaseParser.CURRENT, SqlBaseParser.DATA, SqlBaseParser.DATE, SqlBaseParser.DAY, SqlBaseParser.DESC, SqlBaseParser.DISTRIBUTED, SqlBaseParser.EXCLUDING, SqlBaseParser.EXISTS, SqlBaseParser.EXPLAIN, SqlBaseParser.FALSE, SqlBaseParser.FILTER, SqlBaseParser.FIRST, SqlBaseParser.FOLLOWING, SqlBaseParser.FORMAT, SqlBaseParser.FUNCTIONS, SqlBaseParser.GRANT, SqlBaseParser.GRANTS, SqlBaseParser.GRAPHVIZ, SqlBaseParser.HOUR, SqlBaseParser.IF, SqlBaseParser.INCLUDING, SqlBaseParser.INPUT, SqlBaseParser.INTEGER, SqlBaseParser.INTERVAL, SqlBaseParser.ISOLATION, SqlBaseParser.LAST, SqlBaseParser.LATERAL, SqlBaseParser.LEVEL, SqlBaseParser.LIMIT, SqlBaseParser.LOGICAL, SqlBaseParser.MAP, SqlBaseParser.MINUTE, SqlBaseParser.MONTH, SqlBaseParser.NFC, SqlBaseParser.NFD, SqlBaseParser.NFKC, SqlBaseParser.NFKD, SqlBaseParser.NO, SqlBaseParser.NULL, SqlBaseParser.NULLIF, SqlBaseParser.NULLS, SqlBaseParser.ONLY, SqlBaseParser.OPTION, SqlBaseParser.ORDINALITY, SqlBaseParser.OUTPUT, SqlBaseParser.OVER, SqlBaseParser.PARTITION, SqlBaseParser.PARTITIONS, SqlBaseParser.POSITION, SqlBaseParser.PRECEDING, SqlBaseParser.PRIVILEGES, SqlBaseParser.PROPERTIES, SqlBaseParser.PUBLIC, SqlBaseParser.RANGE, SqlBaseParser.READ, SqlBaseParser.RENAME, SqlBaseParser.REPEATABLE, SqlBaseParser.REPLACE, SqlBaseParser.RESET, SqlBaseParser.RESTRICT, SqlBaseParser.REVOKE, SqlBaseParser.ROLLBACK, SqlBaseParser.ROW, SqlBaseParser.ROWS, SqlBaseParser.SCHEMA, SqlBaseParser.SCHEMAS, SqlBaseParser.SECOND, SqlBaseParser.SESSION, SqlBaseParser.SET, SqlBaseParser.SETS, SqlBaseParser.SHOW, SqlBaseParser.SMALLINT, SqlBaseParser.SOME, SqlBaseParser.START, SqlBaseParser.STATS, SqlBaseParser.SUBSTRING, SqlBaseParser.SYSTEM, SqlBaseParser.TABLES, SqlBaseParser.TABLESAMPLE, SqlBaseParser.TEXT, SqlBaseParser.TIME, SqlBaseParser.TIMESTAMP, SqlBaseParser.TINYINT, SqlBaseParser.TO, SqlBaseParser.TRUE, SqlBaseParser.TRY_CAST, SqlBaseParser.TYPE, SqlBaseParser.UNBOUNDED, SqlBaseParser.UNCOMMITTED, SqlBaseParser.USE, SqlBaseParser.VALIDATE, SqlBaseParser.VERBOSE, SqlBaseParser.VIEW, SqlBaseParser.WORK, SqlBaseParser.WRITE, SqlBaseParser.YEAR, SqlBaseParser.ZONE, SqlBaseParser.STRING, SqlBaseParser.UNICODE_STRING, SqlBaseParser.BINARY_LITERAL, SqlBaseParser.INTEGER_VALUE, SqlBaseParser.DECIMAL_VALUE, SqlBaseParser.IDENTIFIER, SqlBaseParser.DIGIT_IDENTIFIER, SqlBaseParser.BACKQUOTED_IDENTIFIER, SqlBaseParser.DOUBLE_PRECISION]:
                localctx = SqlBaseParser.ValueExpressionDefaultContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 787
                self.primaryExpression(0)
                pass
            elif token in [SqlBaseParser.PLUS, SqlBaseParser.MINUS]:
                localctx = SqlBaseParser.ArithmeticUnaryContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 788
                localctx.operator = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==SqlBaseParser.PLUS or _la==SqlBaseParser.MINUS):
                    localctx.operator = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 789
                self.valueExpression(4)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 803
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,130,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 801
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,129,self._ctx)
                    if la_ == 1:
                        localctx = SqlBaseParser.ArithmeticBinaryContext(self, SqlBaseParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 792
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 793
                        localctx.operator = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(((((_la - 206)) & ~0x3f) == 0 and ((1 << (_la - 206)) & ((1 << (SqlBaseParser.ASTERISK - 206)) | (1 << (SqlBaseParser.SLASH - 206)) | (1 << (SqlBaseParser.PERCENT - 206)))) != 0)):
                            localctx.operator = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 794
                        localctx.right = self.valueExpression(4)
                        pass

                    elif la_ == 2:
                        localctx = SqlBaseParser.ArithmeticBinaryContext(self, SqlBaseParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 795
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 796
                        localctx.operator = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==SqlBaseParser.PLUS or _la==SqlBaseParser.MINUS):
                            localctx.operator = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 797
                        localctx.right = self.valueExpression(3)
                        pass

                    elif la_ == 3:
                        localctx = SqlBaseParser.ConcatenationContext(self, SqlBaseParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 798
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 799
                        self.match(SqlBaseParser.CONCAT)
                        self.state = 800
                        localctx.right = self.valueExpression(2)
                        pass

             
                self.state = 805
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,130,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_primaryExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class BinaryLiteralContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BINARY_LITERAL(self):
            return self.getToken(SqlBaseParser.BINARY_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryLiteral" ):
                listener.enterBinaryLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryLiteral" ):
                listener.exitBinaryLiteral(self)


    class DereferenceContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.base = None # PrimaryExpressionContext
            self.fieldName = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDereference" ):
                listener.enterDereference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDereference" ):
                listener.exitDereference(self)


    class ColumnReferenceContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnReference" ):
                listener.enterColumnReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnReference" ):
                listener.exitColumnReference(self)


    class NullLiteralContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NULL(self):
            return self.getToken(SqlBaseParser.NULL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNullLiteral" ):
                listener.enterNullLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNullLiteral" ):
                listener.exitNullLiteral(self)


    class ParenthesizedExpressionContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedExpression" ):
                listener.enterParenthesizedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedExpression" ):
                listener.exitParenthesizedExpression(self)


    class StringLiteralContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def string(self):
            return self.getTypedRuleContext(SqlBaseParser.StringContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteral" ):
                listener.enterStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteral" ):
                listener.exitStringLiteral(self)


    class TypeConstructorContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)

        def string(self):
            return self.getTypedRuleContext(SqlBaseParser.StringContext,0)

        def DOUBLE_PRECISION(self):
            return self.getToken(SqlBaseParser.DOUBLE_PRECISION, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeConstructor" ):
                listener.enterTypeConstructor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeConstructor" ):
                listener.exitTypeConstructor(self)


    class FunctionCallContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def qualifiedName(self):
            return self.getTypedRuleContext(SqlBaseParser.QualifiedNameContext,0)

        def ASTERISK(self):
            return self.getToken(SqlBaseParser.ASTERISK, 0)
        def filter(self):
            return self.getTypedRuleContext(SqlBaseParser.FilterContext,0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,i)

        def setQuantifier(self):
            return self.getTypedRuleContext(SqlBaseParser.SetQuantifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)


    class ExistsContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXISTS(self):
            return self.getToken(SqlBaseParser.EXISTS, 0)
        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExists" ):
                listener.enterExists(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExists" ):
                listener.exitExists(self)


    class SubqueryExpressionContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubqueryExpression" ):
                listener.enterSubqueryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubqueryExpression" ):
                listener.exitSubqueryExpression(self)


    class NumericLiteralContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def number(self):
            return self.getTypedRuleContext(SqlBaseParser.NumberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericLiteral" ):
                listener.enterNumericLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericLiteral" ):
                listener.exitNumericLiteral(self)


    class BooleanLiteralContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def booleanValue(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanValueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanLiteral" ):
                listener.enterBooleanLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanLiteral" ):
                listener.exitBooleanLiteral(self)



    def primaryExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlBaseParser.PrimaryExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 64
        self.enterRecursionRule(localctx, 64, self.RULE_primaryExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 857
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,136,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.NullLiteralContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 807
                self.match(SqlBaseParser.NULL)
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.TypeConstructorContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 808
                self.identifier()
                self.state = 809
                self.string()
                pass

            elif la_ == 3:
                localctx = SqlBaseParser.TypeConstructorContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 811
                self.match(SqlBaseParser.DOUBLE_PRECISION)
                self.state = 812
                self.string()
                pass

            elif la_ == 4:
                localctx = SqlBaseParser.NumericLiteralContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 813
                self.number()
                pass

            elif la_ == 5:
                localctx = SqlBaseParser.BooleanLiteralContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 814
                self.booleanValue()
                pass

            elif la_ == 6:
                localctx = SqlBaseParser.StringLiteralContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 815
                self.string()
                pass

            elif la_ == 7:
                localctx = SqlBaseParser.BinaryLiteralContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 816
                self.match(SqlBaseParser.BINARY_LITERAL)
                pass

            elif la_ == 8:
                localctx = SqlBaseParser.FunctionCallContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 817
                self.qualifiedName()
                self.state = 818
                self.match(SqlBaseParser.T__0)
                self.state = 819
                self.match(SqlBaseParser.ASTERISK)
                self.state = 820
                self.match(SqlBaseParser.T__2)
                self.state = 822
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,131,self._ctx)
                if la_ == 1:
                    self.state = 821
                    self.filter()


                pass

            elif la_ == 9:
                localctx = SqlBaseParser.FunctionCallContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 824
                self.qualifiedName()
                self.state = 825
                self.match(SqlBaseParser.T__0)
                self.state = 837
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SqlBaseParser.T__0) | (1 << SqlBaseParser.ADD) | (1 << SqlBaseParser.ALL) | (1 << SqlBaseParser.ANALYZE) | (1 << SqlBaseParser.ANY) | (1 << SqlBaseParser.ARRAY) | (1 << SqlBaseParser.ASC) | (1 << SqlBaseParser.AT) | (1 << SqlBaseParser.BERNOULLI) | (1 << SqlBaseParser.CALL) | (1 << SqlBaseParser.CASCADE) | (1 << SqlBaseParser.CATALOGS) | (1 << SqlBaseParser.COALESCE) | (1 << SqlBaseParser.COLUMN) | (1 << SqlBaseParser.COLUMNS) | (1 << SqlBaseParser.COMMENT) | (1 << SqlBaseParser.COMMIT) | (1 << SqlBaseParser.COMMITTED) | (1 << SqlBaseParser.CURRENT) | (1 << SqlBaseParser.DATA) | (1 << SqlBaseParser.DATE) | (1 << SqlBaseParser.DAY) | (1 << SqlBaseParser.DESC) | (1 << SqlBaseParser.DISTINCT) | (1 << SqlBaseParser.DISTRIBUTED) | (1 << SqlBaseParser.EXCLUDING) | (1 << SqlBaseParser.EXISTS) | (1 << SqlBaseParser.EXPLAIN) | (1 << SqlBaseParser.FALSE) | (1 << SqlBaseParser.FILTER))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (SqlBaseParser.FIRST - 64)) | (1 << (SqlBaseParser.FOLLOWING - 64)) | (1 << (SqlBaseParser.FORMAT - 64)) | (1 << (SqlBaseParser.FUNCTIONS - 64)) | (1 << (SqlBaseParser.GRANT - 64)) | (1 << (SqlBaseParser.GRANTS - 64)) | (1 << (SqlBaseParser.GRAPHVIZ - 64)) | (1 << (SqlBaseParser.HOUR - 64)) | (1 << (SqlBaseParser.IF - 64)) | (1 << (SqlBaseParser.INCLUDING - 64)) | (1 << (SqlBaseParser.INPUT - 64)) | (1 << (SqlBaseParser.INTEGER - 64)) | (1 << (SqlBaseParser.INTERVAL - 64)) | (1 << (SqlBaseParser.ISOLATION - 64)) | (1 << (SqlBaseParser.LAST - 64)) | (1 << (SqlBaseParser.LATERAL - 64)) | (1 << (SqlBaseParser.LEVEL - 64)) | (1 << (SqlBaseParser.LIMIT - 64)) | (1 << (SqlBaseParser.LOGICAL - 64)) | (1 << (SqlBaseParser.MAP - 64)) | (1 << (SqlBaseParser.MINUTE - 64)) | (1 << (SqlBaseParser.MONTH - 64)) | (1 << (SqlBaseParser.NFC - 64)) | (1 << (SqlBaseParser.NFD - 64)) | (1 << (SqlBaseParser.NFKC - 64)) | (1 << (SqlBaseParser.NFKD - 64)) | (1 << (SqlBaseParser.NO - 64)) | (1 << (SqlBaseParser.NOT - 64)) | (1 << (SqlBaseParser.NULL - 64)) | (1 << (SqlBaseParser.NULLIF - 64)) | (1 << (SqlBaseParser.NULLS - 64)) | (1 << (SqlBaseParser.ONLY - 64)) | (1 << (SqlBaseParser.OPTION - 64)) | (1 << (SqlBaseParser.ORDINALITY - 64)) | (1 << (SqlBaseParser.OUTPUT - 64)) | (1 << (SqlBaseParser.OVER - 64)) | (1 << (SqlBaseParser.PARTITION - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (SqlBaseParser.PARTITIONS - 128)) | (1 << (SqlBaseParser.POSITION - 128)) | (1 << (SqlBaseParser.PRECEDING - 128)) | (1 << (SqlBaseParser.PRIVILEGES - 128)) | (1 << (SqlBaseParser.PROPERTIES - 128)) | (1 << (SqlBaseParser.PUBLIC - 128)) | (1 << (SqlBaseParser.RANGE - 128)) | (1 << (SqlBaseParser.READ - 128)) | (1 << (SqlBaseParser.RENAME - 128)) | (1 << (SqlBaseParser.REPEATABLE - 128)) | (1 << (SqlBaseParser.REPLACE - 128)) | (1 << (SqlBaseParser.RESET - 128)) | (1 << (SqlBaseParser.RESTRICT - 128)) | (1 << (SqlBaseParser.REVOKE - 128)) | (1 << (SqlBaseParser.ROLLBACK - 128)) | (1 << (SqlBaseParser.ROW - 128)) | (1 << (SqlBaseParser.ROWS - 128)) | (1 << (SqlBaseParser.SCHEMA - 128)) | (1 << (SqlBaseParser.SCHEMAS - 128)) | (1 << (SqlBaseParser.SECOND - 128)) | (1 << (SqlBaseParser.SESSION - 128)) | (1 << (SqlBaseParser.SET - 128)) | (1 << (SqlBaseParser.SETS - 128)) | (1 << (SqlBaseParser.SHOW - 128)) | (1 << (SqlBaseParser.SMALLINT - 128)) | (1 << (SqlBaseParser.SOME - 128)) | (1 << (SqlBaseParser.START - 128)) | (1 << (SqlBaseParser.STATS - 128)) | (1 << (SqlBaseParser.SUBSTRING - 128)) | (1 << (SqlBaseParser.SYSTEM - 128)) | (1 << (SqlBaseParser.TABLES - 128)) | (1 << (SqlBaseParser.TABLESAMPLE - 128)) | (1 << (SqlBaseParser.TEXT - 128)) | (1 << (SqlBaseParser.TIME - 128)) | (1 << (SqlBaseParser.TIMESTAMP - 128)) | (1 << (SqlBaseParser.TINYINT - 128)) | (1 << (SqlBaseParser.TO - 128)) | (1 << (SqlBaseParser.TRUE - 128)) | (1 << (SqlBaseParser.TRY_CAST - 128)) | (1 << (SqlBaseParser.TYPE - 128)) | (1 << (SqlBaseParser.UNBOUNDED - 128)) | (1 << (SqlBaseParser.UNCOMMITTED - 128)) | (1 << (SqlBaseParser.USE - 128)) | (1 << (SqlBaseParser.VALIDATE - 128)) | (1 << (SqlBaseParser.VERBOSE - 128)) | (1 << (SqlBaseParser.VIEW - 128)))) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & ((1 << (SqlBaseParser.WORK - 194)) | (1 << (SqlBaseParser.WRITE - 194)) | (1 << (SqlBaseParser.YEAR - 194)) | (1 << (SqlBaseParser.ZONE - 194)) | (1 << (SqlBaseParser.PLUS - 194)) | (1 << (SqlBaseParser.MINUS - 194)) | (1 << (SqlBaseParser.STRING - 194)) | (1 << (SqlBaseParser.UNICODE_STRING - 194)) | (1 << (SqlBaseParser.BINARY_LITERAL - 194)) | (1 << (SqlBaseParser.INTEGER_VALUE - 194)) | (1 << (SqlBaseParser.DECIMAL_VALUE - 194)) | (1 << (SqlBaseParser.IDENTIFIER - 194)) | (1 << (SqlBaseParser.DIGIT_IDENTIFIER - 194)) | (1 << (SqlBaseParser.BACKQUOTED_IDENTIFIER - 194)) | (1 << (SqlBaseParser.DOUBLE_PRECISION - 194)))) != 0):
                    self.state = 827
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,132,self._ctx)
                    if la_ == 1:
                        self.state = 826
                        self.setQuantifier()


                    self.state = 829
                    self.expression()
                    self.state = 834
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==SqlBaseParser.T__1:
                        self.state = 830
                        self.match(SqlBaseParser.T__1)
                        self.state = 831
                        self.expression()
                        self.state = 836
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 839
                self.match(SqlBaseParser.T__2)
                self.state = 841
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,135,self._ctx)
                if la_ == 1:
                    self.state = 840
                    self.filter()


                pass

            elif la_ == 10:
                localctx = SqlBaseParser.SubqueryExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 843
                self.match(SqlBaseParser.T__0)
                self.state = 844
                self.query()
                self.state = 845
                self.match(SqlBaseParser.T__2)
                pass

            elif la_ == 11:
                localctx = SqlBaseParser.ExistsContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 847
                self.match(SqlBaseParser.EXISTS)
                self.state = 848
                self.match(SqlBaseParser.T__0)
                self.state = 849
                self.query()
                self.state = 850
                self.match(SqlBaseParser.T__2)
                pass

            elif la_ == 12:
                localctx = SqlBaseParser.ColumnReferenceContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 852
                self.identifier()
                pass

            elif la_ == 13:
                localctx = SqlBaseParser.ParenthesizedExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 853
                self.match(SqlBaseParser.T__0)
                self.state = 854
                self.expression()
                self.state = 855
                self.match(SqlBaseParser.T__2)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 864
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,137,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = SqlBaseParser.DereferenceContext(self, SqlBaseParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                    localctx.base = _prevctx
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                    self.state = 859
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 860
                    self.match(SqlBaseParser.T__3)
                    self.state = 861
                    localctx.fieldName = self.identifier() 
                self.state = 866
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,137,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class StringContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_string

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UnicodeStringLiteralContext(StringContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.StringContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def UNICODE_STRING(self):
            return self.getToken(SqlBaseParser.UNICODE_STRING, 0)
        def UESCAPE(self):
            return self.getToken(SqlBaseParser.UESCAPE, 0)
        def STRING(self):
            return self.getToken(SqlBaseParser.STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnicodeStringLiteral" ):
                listener.enterUnicodeStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnicodeStringLiteral" ):
                listener.exitUnicodeStringLiteral(self)


    class BasicStringLiteralContext(StringContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.StringContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(SqlBaseParser.STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBasicStringLiteral" ):
                listener.enterBasicStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBasicStringLiteral" ):
                listener.exitBasicStringLiteral(self)



    def string(self):

        localctx = SqlBaseParser.StringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_string)
        try:
            self.state = 873
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlBaseParser.STRING]:
                localctx = SqlBaseParser.BasicStringLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 867
                self.match(SqlBaseParser.STRING)
                pass
            elif token in [SqlBaseParser.UNICODE_STRING]:
                localctx = SqlBaseParser.UnicodeStringLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 868
                self.match(SqlBaseParser.UNICODE_STRING)
                self.state = 871
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,138,self._ctx)
                if la_ == 1:
                    self.state = 869
                    self.match(SqlBaseParser.UESCAPE)
                    self.state = 870
                    self.match(SqlBaseParser.STRING)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(SqlBaseParser.EQ, 0)

        def NEQ(self):
            return self.getToken(SqlBaseParser.NEQ, 0)

        def LT(self):
            return self.getToken(SqlBaseParser.LT, 0)

        def LTE(self):
            return self.getToken(SqlBaseParser.LTE, 0)

        def GT(self):
            return self.getToken(SqlBaseParser.GT, 0)

        def GTE(self):
            return self.getToken(SqlBaseParser.GTE, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOperator" ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOperator" ):
                listener.exitComparisonOperator(self)




    def comparisonOperator(self):

        localctx = SqlBaseParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 875
            _la = self._input.LA(1)
            if not(((((_la - 198)) & ~0x3f) == 0 and ((1 << (_la - 198)) & ((1 << (SqlBaseParser.EQ - 198)) | (1 << (SqlBaseParser.NEQ - 198)) | (1 << (SqlBaseParser.LT - 198)) | (1 << (SqlBaseParser.LTE - 198)) | (1 << (SqlBaseParser.GT - 198)) | (1 << (SqlBaseParser.GTE - 198)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonQuantifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL(self):
            return self.getToken(SqlBaseParser.ALL, 0)

        def SOME(self):
            return self.getToken(SqlBaseParser.SOME, 0)

        def ANY(self):
            return self.getToken(SqlBaseParser.ANY, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_comparisonQuantifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonQuantifier" ):
                listener.enterComparisonQuantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonQuantifier" ):
                listener.exitComparisonQuantifier(self)




    def comparisonQuantifier(self):

        localctx = SqlBaseParser.ComparisonQuantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_comparisonQuantifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 877
            _la = self._input.LA(1)
            if not(_la==SqlBaseParser.ALL or _la==SqlBaseParser.ANY or _la==SqlBaseParser.SOME):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(SqlBaseParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(SqlBaseParser.FALSE, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanValue" ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanValue" ):
                listener.exitBooleanValue(self)




    def booleanValue(self):

        localctx = SqlBaseParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 879
            _la = self._input.LA(1)
            if not(_la==SqlBaseParser.FALSE or _la==SqlBaseParser.TRUE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(SqlBaseParser.ARRAY, 0)

        def LT(self):
            return self.getToken(SqlBaseParser.LT, 0)

        def type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.TypeContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.TypeContext,i)


        def GT(self):
            return self.getToken(SqlBaseParser.GT, 0)

        def MAP(self):
            return self.getToken(SqlBaseParser.MAP, 0)

        def ROW(self):
            return self.getToken(SqlBaseParser.ROW, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,i)


        def baseType(self):
            return self.getTypedRuleContext(SqlBaseParser.BaseTypeContext,0)


        def typeParameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.TypeParameterContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.TypeParameterContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType" ):
                listener.enterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType" ):
                listener.exitType(self)



    def type(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlBaseParser.TypeContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 74
        self.enterRecursionRule(localctx, 74, self.RULE_type, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 923
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,143,self._ctx)
            if la_ == 1:
                self.state = 882
                self.match(SqlBaseParser.ARRAY)
                self.state = 883
                self.match(SqlBaseParser.LT)
                self.state = 884
                self.type(0)
                self.state = 885
                self.match(SqlBaseParser.GT)
                pass

            elif la_ == 2:
                self.state = 887
                self.match(SqlBaseParser.MAP)
                self.state = 888
                self.match(SqlBaseParser.LT)
                self.state = 889
                self.type(0)
                self.state = 890
                self.match(SqlBaseParser.T__1)
                self.state = 891
                self.type(0)
                self.state = 892
                self.match(SqlBaseParser.GT)
                pass

            elif la_ == 3:
                self.state = 894
                self.match(SqlBaseParser.ROW)
                self.state = 895
                self.match(SqlBaseParser.T__0)
                self.state = 896
                self.identifier()
                self.state = 897
                self.type(0)
                self.state = 904
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SqlBaseParser.T__1:
                    self.state = 898
                    self.match(SqlBaseParser.T__1)
                    self.state = 899
                    self.identifier()
                    self.state = 900
                    self.type(0)
                    self.state = 906
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 907
                self.match(SqlBaseParser.T__2)
                pass

            elif la_ == 4:
                self.state = 909
                self.baseType()
                self.state = 921
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,142,self._ctx)
                if la_ == 1:
                    self.state = 910
                    self.match(SqlBaseParser.T__0)
                    self.state = 911
                    self.typeParameter()
                    self.state = 916
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==SqlBaseParser.T__1:
                        self.state = 912
                        self.match(SqlBaseParser.T__1)
                        self.state = 913
                        self.typeParameter()
                        self.state = 918
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 919
                    self.match(SqlBaseParser.T__2)


                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 929
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,144,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = SqlBaseParser.TypeContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_type)
                    self.state = 925
                    if not self.precpred(self._ctx, 5):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                    self.state = 926
                    self.match(SqlBaseParser.ARRAY) 
                self.state = 931
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,144,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class TypeParameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER_VALUE(self):
            return self.getToken(SqlBaseParser.INTEGER_VALUE, 0)

        def type(self):
            return self.getTypedRuleContext(SqlBaseParser.TypeContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_typeParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeParameter" ):
                listener.enterTypeParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeParameter" ):
                listener.exitTypeParameter(self)




    def typeParameter(self):

        localctx = SqlBaseParser.TypeParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_typeParameter)
        try:
            self.state = 934
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlBaseParser.INTEGER_VALUE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 932
                self.match(SqlBaseParser.INTEGER_VALUE)
                pass
            elif token in [SqlBaseParser.ADD, SqlBaseParser.ALL, SqlBaseParser.ANALYZE, SqlBaseParser.ANY, SqlBaseParser.ARRAY, SqlBaseParser.ASC, SqlBaseParser.AT, SqlBaseParser.BERNOULLI, SqlBaseParser.CALL, SqlBaseParser.CASCADE, SqlBaseParser.CATALOGS, SqlBaseParser.COALESCE, SqlBaseParser.COLUMN, SqlBaseParser.COLUMNS, SqlBaseParser.COMMENT, SqlBaseParser.COMMIT, SqlBaseParser.COMMITTED, SqlBaseParser.CURRENT, SqlBaseParser.DATA, SqlBaseParser.DATE, SqlBaseParser.DAY, SqlBaseParser.DESC, SqlBaseParser.DISTRIBUTED, SqlBaseParser.EXCLUDING, SqlBaseParser.EXPLAIN, SqlBaseParser.FILTER, SqlBaseParser.FIRST, SqlBaseParser.FOLLOWING, SqlBaseParser.FORMAT, SqlBaseParser.FUNCTIONS, SqlBaseParser.GRANT, SqlBaseParser.GRANTS, SqlBaseParser.GRAPHVIZ, SqlBaseParser.HOUR, SqlBaseParser.IF, SqlBaseParser.INCLUDING, SqlBaseParser.INPUT, SqlBaseParser.INTEGER, SqlBaseParser.INTERVAL, SqlBaseParser.ISOLATION, SqlBaseParser.LAST, SqlBaseParser.LATERAL, SqlBaseParser.LEVEL, SqlBaseParser.LIMIT, SqlBaseParser.LOGICAL, SqlBaseParser.MAP, SqlBaseParser.MINUTE, SqlBaseParser.MONTH, SqlBaseParser.NFC, SqlBaseParser.NFD, SqlBaseParser.NFKC, SqlBaseParser.NFKD, SqlBaseParser.NO, SqlBaseParser.NULLIF, SqlBaseParser.NULLS, SqlBaseParser.ONLY, SqlBaseParser.OPTION, SqlBaseParser.ORDINALITY, SqlBaseParser.OUTPUT, SqlBaseParser.OVER, SqlBaseParser.PARTITION, SqlBaseParser.PARTITIONS, SqlBaseParser.POSITION, SqlBaseParser.PRECEDING, SqlBaseParser.PRIVILEGES, SqlBaseParser.PROPERTIES, SqlBaseParser.PUBLIC, SqlBaseParser.RANGE, SqlBaseParser.READ, SqlBaseParser.RENAME, SqlBaseParser.REPEATABLE, SqlBaseParser.REPLACE, SqlBaseParser.RESET, SqlBaseParser.RESTRICT, SqlBaseParser.REVOKE, SqlBaseParser.ROLLBACK, SqlBaseParser.ROW, SqlBaseParser.ROWS, SqlBaseParser.SCHEMA, SqlBaseParser.SCHEMAS, SqlBaseParser.SECOND, SqlBaseParser.SESSION, SqlBaseParser.SET, SqlBaseParser.SETS, SqlBaseParser.SHOW, SqlBaseParser.SMALLINT, SqlBaseParser.SOME, SqlBaseParser.START, SqlBaseParser.STATS, SqlBaseParser.SUBSTRING, SqlBaseParser.SYSTEM, SqlBaseParser.TABLES, SqlBaseParser.TABLESAMPLE, SqlBaseParser.TEXT, SqlBaseParser.TIME, SqlBaseParser.TIMESTAMP, SqlBaseParser.TINYINT, SqlBaseParser.TO, SqlBaseParser.TRY_CAST, SqlBaseParser.TYPE, SqlBaseParser.UNBOUNDED, SqlBaseParser.UNCOMMITTED, SqlBaseParser.USE, SqlBaseParser.VALIDATE, SqlBaseParser.VERBOSE, SqlBaseParser.VIEW, SqlBaseParser.WORK, SqlBaseParser.WRITE, SqlBaseParser.YEAR, SqlBaseParser.ZONE, SqlBaseParser.IDENTIFIER, SqlBaseParser.DIGIT_IDENTIFIER, SqlBaseParser.BACKQUOTED_IDENTIFIER, SqlBaseParser.TIME_WITH_TIME_ZONE, SqlBaseParser.TIMESTAMP_WITH_TIME_ZONE, SqlBaseParser.DOUBLE_PRECISION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 933
                self.type(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BaseTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIME_WITH_TIME_ZONE(self):
            return self.getToken(SqlBaseParser.TIME_WITH_TIME_ZONE, 0)

        def TIMESTAMP_WITH_TIME_ZONE(self):
            return self.getToken(SqlBaseParser.TIMESTAMP_WITH_TIME_ZONE, 0)

        def DOUBLE_PRECISION(self):
            return self.getToken(SqlBaseParser.DOUBLE_PRECISION, 0)

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_baseType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBaseType" ):
                listener.enterBaseType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBaseType" ):
                listener.exitBaseType(self)




    def baseType(self):

        localctx = SqlBaseParser.BaseTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_baseType)
        try:
            self.state = 940
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlBaseParser.TIME_WITH_TIME_ZONE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 936
                self.match(SqlBaseParser.TIME_WITH_TIME_ZONE)
                pass
            elif token in [SqlBaseParser.TIMESTAMP_WITH_TIME_ZONE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 937
                self.match(SqlBaseParser.TIMESTAMP_WITH_TIME_ZONE)
                pass
            elif token in [SqlBaseParser.DOUBLE_PRECISION]:
                self.enterOuterAlt(localctx, 3)
                self.state = 938
                self.match(SqlBaseParser.DOUBLE_PRECISION)
                pass
            elif token in [SqlBaseParser.ADD, SqlBaseParser.ALL, SqlBaseParser.ANALYZE, SqlBaseParser.ANY, SqlBaseParser.ARRAY, SqlBaseParser.ASC, SqlBaseParser.AT, SqlBaseParser.BERNOULLI, SqlBaseParser.CALL, SqlBaseParser.CASCADE, SqlBaseParser.CATALOGS, SqlBaseParser.COALESCE, SqlBaseParser.COLUMN, SqlBaseParser.COLUMNS, SqlBaseParser.COMMENT, SqlBaseParser.COMMIT, SqlBaseParser.COMMITTED, SqlBaseParser.CURRENT, SqlBaseParser.DATA, SqlBaseParser.DATE, SqlBaseParser.DAY, SqlBaseParser.DESC, SqlBaseParser.DISTRIBUTED, SqlBaseParser.EXCLUDING, SqlBaseParser.EXPLAIN, SqlBaseParser.FILTER, SqlBaseParser.FIRST, SqlBaseParser.FOLLOWING, SqlBaseParser.FORMAT, SqlBaseParser.FUNCTIONS, SqlBaseParser.GRANT, SqlBaseParser.GRANTS, SqlBaseParser.GRAPHVIZ, SqlBaseParser.HOUR, SqlBaseParser.IF, SqlBaseParser.INCLUDING, SqlBaseParser.INPUT, SqlBaseParser.INTEGER, SqlBaseParser.INTERVAL, SqlBaseParser.ISOLATION, SqlBaseParser.LAST, SqlBaseParser.LATERAL, SqlBaseParser.LEVEL, SqlBaseParser.LIMIT, SqlBaseParser.LOGICAL, SqlBaseParser.MAP, SqlBaseParser.MINUTE, SqlBaseParser.MONTH, SqlBaseParser.NFC, SqlBaseParser.NFD, SqlBaseParser.NFKC, SqlBaseParser.NFKD, SqlBaseParser.NO, SqlBaseParser.NULLIF, SqlBaseParser.NULLS, SqlBaseParser.ONLY, SqlBaseParser.OPTION, SqlBaseParser.ORDINALITY, SqlBaseParser.OUTPUT, SqlBaseParser.OVER, SqlBaseParser.PARTITION, SqlBaseParser.PARTITIONS, SqlBaseParser.POSITION, SqlBaseParser.PRECEDING, SqlBaseParser.PRIVILEGES, SqlBaseParser.PROPERTIES, SqlBaseParser.PUBLIC, SqlBaseParser.RANGE, SqlBaseParser.READ, SqlBaseParser.RENAME, SqlBaseParser.REPEATABLE, SqlBaseParser.REPLACE, SqlBaseParser.RESET, SqlBaseParser.RESTRICT, SqlBaseParser.REVOKE, SqlBaseParser.ROLLBACK, SqlBaseParser.ROW, SqlBaseParser.ROWS, SqlBaseParser.SCHEMA, SqlBaseParser.SCHEMAS, SqlBaseParser.SECOND, SqlBaseParser.SESSION, SqlBaseParser.SET, SqlBaseParser.SETS, SqlBaseParser.SHOW, SqlBaseParser.SMALLINT, SqlBaseParser.SOME, SqlBaseParser.START, SqlBaseParser.STATS, SqlBaseParser.SUBSTRING, SqlBaseParser.SYSTEM, SqlBaseParser.TABLES, SqlBaseParser.TABLESAMPLE, SqlBaseParser.TEXT, SqlBaseParser.TIME, SqlBaseParser.TIMESTAMP, SqlBaseParser.TINYINT, SqlBaseParser.TO, SqlBaseParser.TRY_CAST, SqlBaseParser.TYPE, SqlBaseParser.UNBOUNDED, SqlBaseParser.UNCOMMITTED, SqlBaseParser.USE, SqlBaseParser.VALIDATE, SqlBaseParser.VERBOSE, SqlBaseParser.VIEW, SqlBaseParser.WORK, SqlBaseParser.WRITE, SqlBaseParser.YEAR, SqlBaseParser.ZONE, SqlBaseParser.IDENTIFIER, SqlBaseParser.DIGIT_IDENTIFIER, SqlBaseParser.BACKQUOTED_IDENTIFIER]:
                self.enterOuterAlt(localctx, 4)
                self.state = 939
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhenClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.condition = None # ExpressionContext
            self.result = None # ExpressionContext

        def WHEN(self):
            return self.getToken(SqlBaseParser.WHEN, 0)

        def THEN(self):
            return self.getToken(SqlBaseParser.THEN, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_whenClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhenClause" ):
                listener.enterWhenClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhenClause" ):
                listener.exitWhenClause(self)




    def whenClause(self):

        localctx = SqlBaseParser.WhenClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_whenClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 942
            self.match(SqlBaseParser.WHEN)
            self.state = 943
            localctx.condition = self.expression()
            self.state = 944
            self.match(SqlBaseParser.THEN)
            self.state = 945
            localctx.result = self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILTER(self):
            return self.getToken(SqlBaseParser.FILTER, 0)

        def WHERE(self):
            return self.getToken(SqlBaseParser.WHERE, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_filter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilter" ):
                listener.enterFilter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilter" ):
                listener.exitFilter(self)




    def filter(self):

        localctx = SqlBaseParser.FilterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_filter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 947
            self.match(SqlBaseParser.FILTER)
            self.state = 948
            self.match(SqlBaseParser.T__0)
            self.state = 949
            self.match(SqlBaseParser.WHERE)
            self.state = 950
            self.booleanExpression(0)
            self.state = 951
            self.match(SqlBaseParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_qualifiedName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualifiedName" ):
                listener.enterQualifiedName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualifiedName" ):
                listener.exitQualifiedName(self)




    def qualifiedName(self):

        localctx = SqlBaseParser.QualifiedNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_qualifiedName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 953
            self.identifier()
            self.state = 958
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,147,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 954
                    self.match(SqlBaseParser.T__3)
                    self.state = 955
                    self.identifier() 
                self.state = 960
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,147,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_identifier

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class BackQuotedIdentifierContext(IdentifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.IdentifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BACKQUOTED_IDENTIFIER(self):
            return self.getToken(SqlBaseParser.BACKQUOTED_IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBackQuotedIdentifier" ):
                listener.enterBackQuotedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBackQuotedIdentifier" ):
                listener.exitBackQuotedIdentifier(self)


    class DigitIdentifierContext(IdentifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.IdentifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DIGIT_IDENTIFIER(self):
            return self.getToken(SqlBaseParser.DIGIT_IDENTIFIER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDigitIdentifier" ):
                listener.enterDigitIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDigitIdentifier" ):
                listener.exitDigitIdentifier(self)


    class UnquotedIdentifierContext(IdentifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.IdentifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENTIFIER(self):
            return self.getToken(SqlBaseParser.IDENTIFIER, 0)
        def nonReserved(self):
            return self.getTypedRuleContext(SqlBaseParser.NonReservedContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnquotedIdentifier" ):
                listener.enterUnquotedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnquotedIdentifier" ):
                listener.exitUnquotedIdentifier(self)



    def identifier(self):

        localctx = SqlBaseParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_identifier)
        try:
            self.state = 965
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlBaseParser.IDENTIFIER]:
                localctx = SqlBaseParser.UnquotedIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 961
                self.match(SqlBaseParser.IDENTIFIER)
                pass
            elif token in [SqlBaseParser.ADD, SqlBaseParser.ALL, SqlBaseParser.ANALYZE, SqlBaseParser.ANY, SqlBaseParser.ARRAY, SqlBaseParser.ASC, SqlBaseParser.AT, SqlBaseParser.BERNOULLI, SqlBaseParser.CALL, SqlBaseParser.CASCADE, SqlBaseParser.CATALOGS, SqlBaseParser.COALESCE, SqlBaseParser.COLUMN, SqlBaseParser.COLUMNS, SqlBaseParser.COMMENT, SqlBaseParser.COMMIT, SqlBaseParser.COMMITTED, SqlBaseParser.CURRENT, SqlBaseParser.DATA, SqlBaseParser.DATE, SqlBaseParser.DAY, SqlBaseParser.DESC, SqlBaseParser.DISTRIBUTED, SqlBaseParser.EXCLUDING, SqlBaseParser.EXPLAIN, SqlBaseParser.FILTER, SqlBaseParser.FIRST, SqlBaseParser.FOLLOWING, SqlBaseParser.FORMAT, SqlBaseParser.FUNCTIONS, SqlBaseParser.GRANT, SqlBaseParser.GRANTS, SqlBaseParser.GRAPHVIZ, SqlBaseParser.HOUR, SqlBaseParser.IF, SqlBaseParser.INCLUDING, SqlBaseParser.INPUT, SqlBaseParser.INTEGER, SqlBaseParser.INTERVAL, SqlBaseParser.ISOLATION, SqlBaseParser.LAST, SqlBaseParser.LATERAL, SqlBaseParser.LEVEL, SqlBaseParser.LIMIT, SqlBaseParser.LOGICAL, SqlBaseParser.MAP, SqlBaseParser.MINUTE, SqlBaseParser.MONTH, SqlBaseParser.NFC, SqlBaseParser.NFD, SqlBaseParser.NFKC, SqlBaseParser.NFKD, SqlBaseParser.NO, SqlBaseParser.NULLIF, SqlBaseParser.NULLS, SqlBaseParser.ONLY, SqlBaseParser.OPTION, SqlBaseParser.ORDINALITY, SqlBaseParser.OUTPUT, SqlBaseParser.OVER, SqlBaseParser.PARTITION, SqlBaseParser.PARTITIONS, SqlBaseParser.POSITION, SqlBaseParser.PRECEDING, SqlBaseParser.PRIVILEGES, SqlBaseParser.PROPERTIES, SqlBaseParser.PUBLIC, SqlBaseParser.RANGE, SqlBaseParser.READ, SqlBaseParser.RENAME, SqlBaseParser.REPEATABLE, SqlBaseParser.REPLACE, SqlBaseParser.RESET, SqlBaseParser.RESTRICT, SqlBaseParser.REVOKE, SqlBaseParser.ROLLBACK, SqlBaseParser.ROW, SqlBaseParser.ROWS, SqlBaseParser.SCHEMA, SqlBaseParser.SCHEMAS, SqlBaseParser.SECOND, SqlBaseParser.SESSION, SqlBaseParser.SET, SqlBaseParser.SETS, SqlBaseParser.SHOW, SqlBaseParser.SMALLINT, SqlBaseParser.SOME, SqlBaseParser.START, SqlBaseParser.STATS, SqlBaseParser.SUBSTRING, SqlBaseParser.SYSTEM, SqlBaseParser.TABLES, SqlBaseParser.TABLESAMPLE, SqlBaseParser.TEXT, SqlBaseParser.TIME, SqlBaseParser.TIMESTAMP, SqlBaseParser.TINYINT, SqlBaseParser.TO, SqlBaseParser.TRY_CAST, SqlBaseParser.TYPE, SqlBaseParser.UNBOUNDED, SqlBaseParser.UNCOMMITTED, SqlBaseParser.USE, SqlBaseParser.VALIDATE, SqlBaseParser.VERBOSE, SqlBaseParser.VIEW, SqlBaseParser.WORK, SqlBaseParser.WRITE, SqlBaseParser.YEAR, SqlBaseParser.ZONE]:
                localctx = SqlBaseParser.UnquotedIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 962
                self.nonReserved()
                pass
            elif token in [SqlBaseParser.BACKQUOTED_IDENTIFIER]:
                localctx = SqlBaseParser.BackQuotedIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 963
                self.match(SqlBaseParser.BACKQUOTED_IDENTIFIER)
                pass
            elif token in [SqlBaseParser.DIGIT_IDENTIFIER]:
                localctx = SqlBaseParser.DigitIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 964
                self.match(SqlBaseParser.DIGIT_IDENTIFIER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_number

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DecimalLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DECIMAL_VALUE(self):
            return self.getToken(SqlBaseParser.DECIMAL_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecimalLiteral" ):
                listener.enterDecimalLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecimalLiteral" ):
                listener.exitDecimalLiteral(self)


    class IntegerLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INTEGER_VALUE(self):
            return self.getToken(SqlBaseParser.INTEGER_VALUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerLiteral" ):
                listener.enterIntegerLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerLiteral" ):
                listener.exitIntegerLiteral(self)



    def number(self):

        localctx = SqlBaseParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_number)
        try:
            self.state = 969
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlBaseParser.DECIMAL_VALUE]:
                localctx = SqlBaseParser.DecimalLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 967
                self.match(SqlBaseParser.DECIMAL_VALUE)
                pass
            elif token in [SqlBaseParser.INTEGER_VALUE]:
                localctx = SqlBaseParser.IntegerLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 968
                self.match(SqlBaseParser.INTEGER_VALUE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NonReservedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(SqlBaseParser.ADD, 0)

        def ALL(self):
            return self.getToken(SqlBaseParser.ALL, 0)

        def ANALYZE(self):
            return self.getToken(SqlBaseParser.ANALYZE, 0)

        def ANY(self):
            return self.getToken(SqlBaseParser.ANY, 0)

        def ARRAY(self):
            return self.getToken(SqlBaseParser.ARRAY, 0)

        def ASC(self):
            return self.getToken(SqlBaseParser.ASC, 0)

        def AT(self):
            return self.getToken(SqlBaseParser.AT, 0)

        def BERNOULLI(self):
            return self.getToken(SqlBaseParser.BERNOULLI, 0)

        def CALL(self):
            return self.getToken(SqlBaseParser.CALL, 0)

        def CASCADE(self):
            return self.getToken(SqlBaseParser.CASCADE, 0)

        def CATALOGS(self):
            return self.getToken(SqlBaseParser.CATALOGS, 0)

        def COALESCE(self):
            return self.getToken(SqlBaseParser.COALESCE, 0)

        def COLUMN(self):
            return self.getToken(SqlBaseParser.COLUMN, 0)

        def COLUMNS(self):
            return self.getToken(SqlBaseParser.COLUMNS, 0)

        def COMMENT(self):
            return self.getToken(SqlBaseParser.COMMENT, 0)

        def COMMIT(self):
            return self.getToken(SqlBaseParser.COMMIT, 0)

        def COMMITTED(self):
            return self.getToken(SqlBaseParser.COMMITTED, 0)

        def CURRENT(self):
            return self.getToken(SqlBaseParser.CURRENT, 0)

        def DATA(self):
            return self.getToken(SqlBaseParser.DATA, 0)

        def DATE(self):
            return self.getToken(SqlBaseParser.DATE, 0)

        def DAY(self):
            return self.getToken(SqlBaseParser.DAY, 0)

        def DESC(self):
            return self.getToken(SqlBaseParser.DESC, 0)

        def DISTRIBUTED(self):
            return self.getToken(SqlBaseParser.DISTRIBUTED, 0)

        def EXCLUDING(self):
            return self.getToken(SqlBaseParser.EXCLUDING, 0)

        def EXPLAIN(self):
            return self.getToken(SqlBaseParser.EXPLAIN, 0)

        def FILTER(self):
            return self.getToken(SqlBaseParser.FILTER, 0)

        def FIRST(self):
            return self.getToken(SqlBaseParser.FIRST, 0)

        def FOLLOWING(self):
            return self.getToken(SqlBaseParser.FOLLOWING, 0)

        def FORMAT(self):
            return self.getToken(SqlBaseParser.FORMAT, 0)

        def FUNCTIONS(self):
            return self.getToken(SqlBaseParser.FUNCTIONS, 0)

        def GRANT(self):
            return self.getToken(SqlBaseParser.GRANT, 0)

        def GRANTS(self):
            return self.getToken(SqlBaseParser.GRANTS, 0)

        def GRAPHVIZ(self):
            return self.getToken(SqlBaseParser.GRAPHVIZ, 0)

        def HOUR(self):
            return self.getToken(SqlBaseParser.HOUR, 0)

        def IF(self):
            return self.getToken(SqlBaseParser.IF, 0)

        def INCLUDING(self):
            return self.getToken(SqlBaseParser.INCLUDING, 0)

        def INPUT(self):
            return self.getToken(SqlBaseParser.INPUT, 0)

        def INTEGER(self):
            return self.getToken(SqlBaseParser.INTEGER, 0)

        def INTERVAL(self):
            return self.getToken(SqlBaseParser.INTERVAL, 0)

        def ISOLATION(self):
            return self.getToken(SqlBaseParser.ISOLATION, 0)

        def LAST(self):
            return self.getToken(SqlBaseParser.LAST, 0)

        def LATERAL(self):
            return self.getToken(SqlBaseParser.LATERAL, 0)

        def LEVEL(self):
            return self.getToken(SqlBaseParser.LEVEL, 0)

        def LIMIT(self):
            return self.getToken(SqlBaseParser.LIMIT, 0)

        def LOGICAL(self):
            return self.getToken(SqlBaseParser.LOGICAL, 0)

        def MAP(self):
            return self.getToken(SqlBaseParser.MAP, 0)

        def MINUTE(self):
            return self.getToken(SqlBaseParser.MINUTE, 0)

        def MONTH(self):
            return self.getToken(SqlBaseParser.MONTH, 0)

        def NFC(self):
            return self.getToken(SqlBaseParser.NFC, 0)

        def NFD(self):
            return self.getToken(SqlBaseParser.NFD, 0)

        def NFKC(self):
            return self.getToken(SqlBaseParser.NFKC, 0)

        def NFKD(self):
            return self.getToken(SqlBaseParser.NFKD, 0)

        def NO(self):
            return self.getToken(SqlBaseParser.NO, 0)

        def NULLIF(self):
            return self.getToken(SqlBaseParser.NULLIF, 0)

        def NULLS(self):
            return self.getToken(SqlBaseParser.NULLS, 0)

        def ONLY(self):
            return self.getToken(SqlBaseParser.ONLY, 0)

        def OPTION(self):
            return self.getToken(SqlBaseParser.OPTION, 0)

        def ORDINALITY(self):
            return self.getToken(SqlBaseParser.ORDINALITY, 0)

        def OUTPUT(self):
            return self.getToken(SqlBaseParser.OUTPUT, 0)

        def OVER(self):
            return self.getToken(SqlBaseParser.OVER, 0)

        def PARTITION(self):
            return self.getToken(SqlBaseParser.PARTITION, 0)

        def PARTITIONS(self):
            return self.getToken(SqlBaseParser.PARTITIONS, 0)

        def POSITION(self):
            return self.getToken(SqlBaseParser.POSITION, 0)

        def PRECEDING(self):
            return self.getToken(SqlBaseParser.PRECEDING, 0)

        def PRIVILEGES(self):
            return self.getToken(SqlBaseParser.PRIVILEGES, 0)

        def PROPERTIES(self):
            return self.getToken(SqlBaseParser.PROPERTIES, 0)

        def PUBLIC(self):
            return self.getToken(SqlBaseParser.PUBLIC, 0)

        def RANGE(self):
            return self.getToken(SqlBaseParser.RANGE, 0)

        def READ(self):
            return self.getToken(SqlBaseParser.READ, 0)

        def RENAME(self):
            return self.getToken(SqlBaseParser.RENAME, 0)

        def REPEATABLE(self):
            return self.getToken(SqlBaseParser.REPEATABLE, 0)

        def REPLACE(self):
            return self.getToken(SqlBaseParser.REPLACE, 0)

        def RESET(self):
            return self.getToken(SqlBaseParser.RESET, 0)

        def RESTRICT(self):
            return self.getToken(SqlBaseParser.RESTRICT, 0)

        def REVOKE(self):
            return self.getToken(SqlBaseParser.REVOKE, 0)

        def ROLLBACK(self):
            return self.getToken(SqlBaseParser.ROLLBACK, 0)

        def ROW(self):
            return self.getToken(SqlBaseParser.ROW, 0)

        def ROWS(self):
            return self.getToken(SqlBaseParser.ROWS, 0)

        def SCHEMA(self):
            return self.getToken(SqlBaseParser.SCHEMA, 0)

        def SCHEMAS(self):
            return self.getToken(SqlBaseParser.SCHEMAS, 0)

        def SECOND(self):
            return self.getToken(SqlBaseParser.SECOND, 0)

        def SESSION(self):
            return self.getToken(SqlBaseParser.SESSION, 0)

        def SET(self):
            return self.getToken(SqlBaseParser.SET, 0)

        def SETS(self):
            return self.getToken(SqlBaseParser.SETS, 0)

        def SHOW(self):
            return self.getToken(SqlBaseParser.SHOW, 0)

        def SMALLINT(self):
            return self.getToken(SqlBaseParser.SMALLINT, 0)

        def SOME(self):
            return self.getToken(SqlBaseParser.SOME, 0)

        def START(self):
            return self.getToken(SqlBaseParser.START, 0)

        def STATS(self):
            return self.getToken(SqlBaseParser.STATS, 0)

        def SUBSTRING(self):
            return self.getToken(SqlBaseParser.SUBSTRING, 0)

        def SYSTEM(self):
            return self.getToken(SqlBaseParser.SYSTEM, 0)

        def TABLES(self):
            return self.getToken(SqlBaseParser.TABLES, 0)

        def TABLESAMPLE(self):
            return self.getToken(SqlBaseParser.TABLESAMPLE, 0)

        def TEXT(self):
            return self.getToken(SqlBaseParser.TEXT, 0)

        def TIME(self):
            return self.getToken(SqlBaseParser.TIME, 0)

        def TIMESTAMP(self):
            return self.getToken(SqlBaseParser.TIMESTAMP, 0)

        def TINYINT(self):
            return self.getToken(SqlBaseParser.TINYINT, 0)

        def TO(self):
            return self.getToken(SqlBaseParser.TO, 0)

        def TRY_CAST(self):
            return self.getToken(SqlBaseParser.TRY_CAST, 0)

        def TYPE(self):
            return self.getToken(SqlBaseParser.TYPE, 0)

        def UNBOUNDED(self):
            return self.getToken(SqlBaseParser.UNBOUNDED, 0)

        def UNCOMMITTED(self):
            return self.getToken(SqlBaseParser.UNCOMMITTED, 0)

        def USE(self):
            return self.getToken(SqlBaseParser.USE, 0)

        def VALIDATE(self):
            return self.getToken(SqlBaseParser.VALIDATE, 0)

        def VERBOSE(self):
            return self.getToken(SqlBaseParser.VERBOSE, 0)

        def VIEW(self):
            return self.getToken(SqlBaseParser.VIEW, 0)

        def WORK(self):
            return self.getToken(SqlBaseParser.WORK, 0)

        def WRITE(self):
            return self.getToken(SqlBaseParser.WRITE, 0)

        def YEAR(self):
            return self.getToken(SqlBaseParser.YEAR, 0)

        def ZONE(self):
            return self.getToken(SqlBaseParser.ZONE, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_nonReserved

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNonReserved" ):
                listener.enterNonReserved(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNonReserved" ):
                listener.exitNonReserved(self)




    def nonReserved(self):

        localctx = SqlBaseParser.NonReservedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_nonReserved)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 971
            _la = self._input.LA(1)
            if not(((((_la - 5)) & ~0x3f) == 0 and ((1 << (_la - 5)) & ((1 << (SqlBaseParser.ADD - 5)) | (1 << (SqlBaseParser.ALL - 5)) | (1 << (SqlBaseParser.ANALYZE - 5)) | (1 << (SqlBaseParser.ANY - 5)) | (1 << (SqlBaseParser.ARRAY - 5)) | (1 << (SqlBaseParser.ASC - 5)) | (1 << (SqlBaseParser.AT - 5)) | (1 << (SqlBaseParser.BERNOULLI - 5)) | (1 << (SqlBaseParser.CALL - 5)) | (1 << (SqlBaseParser.CASCADE - 5)) | (1 << (SqlBaseParser.CATALOGS - 5)) | (1 << (SqlBaseParser.COALESCE - 5)) | (1 << (SqlBaseParser.COLUMN - 5)) | (1 << (SqlBaseParser.COLUMNS - 5)) | (1 << (SqlBaseParser.COMMENT - 5)) | (1 << (SqlBaseParser.COMMIT - 5)) | (1 << (SqlBaseParser.COMMITTED - 5)) | (1 << (SqlBaseParser.CURRENT - 5)) | (1 << (SqlBaseParser.DATA - 5)) | (1 << (SqlBaseParser.DATE - 5)) | (1 << (SqlBaseParser.DAY - 5)) | (1 << (SqlBaseParser.DESC - 5)) | (1 << (SqlBaseParser.DISTRIBUTED - 5)) | (1 << (SqlBaseParser.EXCLUDING - 5)) | (1 << (SqlBaseParser.EXPLAIN - 5)) | (1 << (SqlBaseParser.FILTER - 5)) | (1 << (SqlBaseParser.FIRST - 5)) | (1 << (SqlBaseParser.FOLLOWING - 5)) | (1 << (SqlBaseParser.FORMAT - 5)))) != 0) or ((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (SqlBaseParser.FUNCTIONS - 70)) | (1 << (SqlBaseParser.GRANT - 70)) | (1 << (SqlBaseParser.GRANTS - 70)) | (1 << (SqlBaseParser.GRAPHVIZ - 70)) | (1 << (SqlBaseParser.HOUR - 70)) | (1 << (SqlBaseParser.IF - 70)) | (1 << (SqlBaseParser.INCLUDING - 70)) | (1 << (SqlBaseParser.INPUT - 70)) | (1 << (SqlBaseParser.INTEGER - 70)) | (1 << (SqlBaseParser.INTERVAL - 70)) | (1 << (SqlBaseParser.ISOLATION - 70)) | (1 << (SqlBaseParser.LAST - 70)) | (1 << (SqlBaseParser.LATERAL - 70)) | (1 << (SqlBaseParser.LEVEL - 70)) | (1 << (SqlBaseParser.LIMIT - 70)) | (1 << (SqlBaseParser.LOGICAL - 70)) | (1 << (SqlBaseParser.MAP - 70)) | (1 << (SqlBaseParser.MINUTE - 70)) | (1 << (SqlBaseParser.MONTH - 70)) | (1 << (SqlBaseParser.NFC - 70)) | (1 << (SqlBaseParser.NFD - 70)) | (1 << (SqlBaseParser.NFKC - 70)) | (1 << (SqlBaseParser.NFKD - 70)) | (1 << (SqlBaseParser.NO - 70)) | (1 << (SqlBaseParser.NULLIF - 70)) | (1 << (SqlBaseParser.NULLS - 70)) | (1 << (SqlBaseParser.ONLY - 70)) | (1 << (SqlBaseParser.OPTION - 70)) | (1 << (SqlBaseParser.ORDINALITY - 70)) | (1 << (SqlBaseParser.OUTPUT - 70)) | (1 << (SqlBaseParser.OVER - 70)) | (1 << (SqlBaseParser.PARTITION - 70)) | (1 << (SqlBaseParser.PARTITIONS - 70)) | (1 << (SqlBaseParser.POSITION - 70)) | (1 << (SqlBaseParser.PRECEDING - 70)) | (1 << (SqlBaseParser.PRIVILEGES - 70)) | (1 << (SqlBaseParser.PROPERTIES - 70)))) != 0) or ((((_la - 134)) & ~0x3f) == 0 and ((1 << (_la - 134)) & ((1 << (SqlBaseParser.PUBLIC - 134)) | (1 << (SqlBaseParser.RANGE - 134)) | (1 << (SqlBaseParser.READ - 134)) | (1 << (SqlBaseParser.RENAME - 134)) | (1 << (SqlBaseParser.REPEATABLE - 134)) | (1 << (SqlBaseParser.REPLACE - 134)) | (1 << (SqlBaseParser.RESET - 134)) | (1 << (SqlBaseParser.RESTRICT - 134)) | (1 << (SqlBaseParser.REVOKE - 134)) | (1 << (SqlBaseParser.ROLLBACK - 134)) | (1 << (SqlBaseParser.ROW - 134)) | (1 << (SqlBaseParser.ROWS - 134)) | (1 << (SqlBaseParser.SCHEMA - 134)) | (1 << (SqlBaseParser.SCHEMAS - 134)) | (1 << (SqlBaseParser.SECOND - 134)) | (1 << (SqlBaseParser.SESSION - 134)) | (1 << (SqlBaseParser.SET - 134)) | (1 << (SqlBaseParser.SETS - 134)) | (1 << (SqlBaseParser.SHOW - 134)) | (1 << (SqlBaseParser.SMALLINT - 134)) | (1 << (SqlBaseParser.SOME - 134)) | (1 << (SqlBaseParser.START - 134)) | (1 << (SqlBaseParser.STATS - 134)) | (1 << (SqlBaseParser.SUBSTRING - 134)) | (1 << (SqlBaseParser.SYSTEM - 134)) | (1 << (SqlBaseParser.TABLES - 134)) | (1 << (SqlBaseParser.TABLESAMPLE - 134)) | (1 << (SqlBaseParser.TEXT - 134)) | (1 << (SqlBaseParser.TIME - 134)) | (1 << (SqlBaseParser.TIMESTAMP - 134)) | (1 << (SqlBaseParser.TINYINT - 134)) | (1 << (SqlBaseParser.TO - 134)) | (1 << (SqlBaseParser.TRY_CAST - 134)) | (1 << (SqlBaseParser.TYPE - 134)) | (1 << (SqlBaseParser.UNBOUNDED - 134)) | (1 << (SqlBaseParser.UNCOMMITTED - 134)) | (1 << (SqlBaseParser.USE - 134)) | (1 << (SqlBaseParser.VALIDATE - 134)) | (1 << (SqlBaseParser.VERBOSE - 134)) | (1 << (SqlBaseParser.VIEW - 134)) | (1 << (SqlBaseParser.WORK - 134)) | (1 << (SqlBaseParser.WRITE - 134)) | (1 << (SqlBaseParser.YEAR - 134)) | (1 << (SqlBaseParser.ZONE - 134)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[21] = self.relation_sempred
        self._predicates[28] = self.booleanExpression_sempred
        self._predicates[31] = self.valueExpression_sempred
        self._predicates[32] = self.primaryExpression_sempred
        self._predicates[37] = self.type_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def relation_sempred(self, localctx:RelationContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 1)
         

    def booleanExpression_sempred(self, localctx:BooleanExpressionContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 1)
         

    def valueExpression_sempred(self, localctx:ValueExpressionContext, predIndex:int):
            if predIndex == 3:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 1)
         

    def primaryExpression_sempred(self, localctx:PrimaryExpressionContext, predIndex:int):
            if predIndex == 6:
                return self.precpred(self._ctx, 2)
         

    def type_sempred(self, localctx:TypeContext, predIndex:int):
            if predIndex == 7:
                return self.precpred(self._ctx, 5)
         




